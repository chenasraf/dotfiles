<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, November 09, 2017, 10:49 AM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "Aardwolf_Showmap" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Aardwolf_Showmap"
   author="Pwar"
   id="63882d1089f727f5f94c3f41"
   language="Lua"
   purpose="Easily access links to external maps."
   date_written="2017-11-09 10:45:25"
   requires="4.76"
   version="1.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[

>    showmap
        - display links to all maps for area you are currently in

>    showmap [areaname]
        - display links to all maps for area you specify 

>    showmap list
        - lists of all areas with external map data (short name)
	
>    showmap togglemirror
        - enables or disables listing of mirror links mode (shows Touchstone hosted links)
	
>    showmap togglevi
        - enables or disables visually impaired mode (opens automatically VI map if available for area)

>    showmap version
        - displays the version of the Showmap plugin (also visible in help)
	
>    showmap update
        - update the map data from the boot map list

>    showmap help
        - shows only this help
	
Special thanks to Touchstone clan for giving me their original database of links and archived maps!

]]>
</description>

</plugin>
<!--  Aliases  -->

<aliases>
  <alias
   match="^showmap (.+)$"
   script="map_showmap"
   omit_from_output="n"
   omit_from_log="n"
   omit_from_command_history="n"
   enabled="y"
   sequence="100"
   regexp="y"
  >
  </alias>
    
  <alias
   match="^showmap$"
   script="map_req_gmcp"
   omit_from_output="n"
   omit_from_log="n"
   omit_from_command_history="n"
   enabled="y"
   sequence="100"
   regexp="y"
  >
  </alias>

  <alias
   match="^showmap reload$"
   script="reload"
   omit_from_output="n"
   omit_from_log="n"
   omit_from_command_history="n"
   enabled="y"
   sequence="99"
   regexp="y"
  >
  </alias>

  <alias
   match="^showmap update$"
   script="update_maps_list"
   omit_from_output="n"
   omit_from_log="n"
   omit_from_command_history="n"
   enabled="y"
   sequence="99"
   regexp="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
	require "gmcphelper"
	require "async"
	require "json"
	require "tprint"
	local currentRoom = {} -- here we will store gmcp room and area data we receive
	local helper_show_maps = 0
	local showmap_ver = "1.1.1"
	local mapTable = {}

	local MAP_LINKS = "https://aardwolfboot.com/maps-json/"
	
	function map_req_gmcp(msg, id, name, text)
		Send_GMCP_Packet("request area") 
		helper_show_maps = 1
	end
	
	function map_req_area(name, line, wildcards)
		map_showmap(nil, nil, wildcards)
	end
	
	function OnPluginBroadcast (msg, id, name, text)
		if (id == '3e7dedbe37e44942dd46d264') then		-- GMCP Handler plugin
			if (text == "room.area") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.area")
				luastmt = "gmcpdata = " .. gmcparg
				assert (loadstring (luastmt or "")) ()
				currentRoom.areaname = gmcpval("name")
			elseif (text == "room.info") then
                                res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
                                luastmt = "gmcpdata = " .. gmcparg
                                assert (loadstring (luastmt or "")) ()
				if (helper_show_maps == 1) then -- we only want to call map_showmap if it was requested
					currentRoom.areaid = gmcpval("zone")
					helper_show_maps = 0
	                        	map_showmap()
				end
			end
		end
	end
	
	function map_showmap (name, line, wildcards)
		local areaid
		local wikiLinks, areaMaps1
		if currentRoom.areaid ~= nil then
	                areaid = string.lower(currentRoom.areaid) -- force lowercase just in case
			currentRoom.areaid = nil
		end
		if (wildcards ~= nil) then -- we have an arg
			wildcards[1] = string.lower(wildcards[1])
			if (wildcards[1] == "help") then
				print("")
				NoteStyle(2)			        
				ColourNote("MediumSeaGreen", "", "Showmap v" .. showmap_ver .. " for Aardwolf by Pwar")
				NoteStyle(0)
				print("")
				--print("===================================")
				ColourNote("SteelBlue", "", GetPluginInfo (GetPluginID (), 3))
				print("")
				return
			elseif (wildcards[1] == "version") then
				print("")
				ColourNote("SteelBlue", "", "Currently running version: ", "MediumSeaGreen", "", "Showmap v" .. showmap_ver .. " by Pwar")
				print("")
				return
			elseif (wildcards[1] == "ft2") then
				wildcards[1] = "ftii"
			elseif (wildcards[1] == "list") then
				list_areas()
				return
			elseif (wildcards[1] == "togglevi") then
				toggle_vi()
				return
			elseif (wildcards[1] == "togglemirror") then
				toggle_mirror()
				return
			else
				areaid = find_area(wildcards[1])
			end
		end

		if (areaid == nil) then
			ColourNote("SteelBlue", "", "Unable to find maps for area name matching: ", "Red", "", wildcards[1])
			print("")
			return
		end
		local foundArea = false
		for i = 1, #mapTable do
			if mapTable[i].Runto == areaid then
				foundArea = true
				wikiLinks = parse_urls(mapTable[i].AreaName)
				areaMaps1 = parse_urls(mapTable[i].Maps)
				areaMaps2 = parse_urls(mapTable[i].Maps2)
				if not areaMaps1 or #areaMaps1 == 0 then
					ColourNote("SteelBlue", "", "Unable to find maps for area name matching: ", "Red", "", areaid)
					return
				end
				NoteStyle(2)
				print("")
				local areaName

				if wikiLinks and #wikiLinks > 0 then
					areaName = wikiLinks[1].Name
				else
					areaName = mapTable[i].AreaName
				end
				ColourNote("SteelBlue", "", areaName .. " (", "MediumSeaGreen", "", mapTable[i].Runto, "SteelBlue", "", ")" .. " - [Lvl " .. mapTable[i].From .. " - " .. mapTable[i].To .. "] -" .. " Builder(s): " .. mapTable[i].Builder)

				NoteStyle(0)
				print("")   

				if (GetVariable("ToggleMirror") == "1") and (GetVariable("ToggleVI") ~= "1") then print("Boot hosted:") end
				local viFound = false
				for i = 1, #areaMaps1 do
					if (GetVariable("ToggleVI") ~= "1") then
						if areaMaps1[i].Name ~= "(VI)" then
							ColourTell("MediumSeaGreen", "", padRight(areaMaps1[i].Name, 20, " "))
							Hyperlink(areaMaps1[i].Url, areaMaps1[i].Url, "[" .. areaMaps1[i].Name .. " Map]", "blue", "", true)
							print("")
						end
					else
						if areaMaps1[i].Name == "(VI)" then
							Note("Opening map for " .. wikiLinks[1].Name)
							OpenBrowser(areaMaps1[i].Url)
							viFound = true
							return
						end
					end
				end
				if (GetVariable("ToggleVI") == "1") and not viFound then
					Note("No VI map found in database for: " .. wikiLinks[1].Name)
					return
				end

				if (GetVariable("ToggleMirror") == "1") and areaMaps2 then
					print("\r\nTouchstone hosted:")
					for i = 1, #areaMaps2 do
						if (GetVariable("ToggleVI") ~= "1") then
							if areaMaps1[i].Name ~= "(VI)" then
								ColourTell("MediumSeaGreen", "", padRight(areaMaps2[i].Name, 20, " "))
								Hyperlink(areaMaps2[i].Url, areaMaps2[i].Url, "[" .. areaMaps2[i].Name .. " Map]", "blue", "", true)
								print("")
							end
						end
					end
				end
				
			print("")
			end
		end
		if not foundArea then
			ColourNote("SteelBlue", "", "Unable to find maps for area name matching: ", "Red", "", areaid)
		end
	end
	
	function find_area(wildcards)
		for i = 1, #mapTable do
			if (string.find(mapTable[i].Runto, wildcards)) ~= nil then
				return mapTable[i].Runto
			end
		end
	end
	
	function list_areas()
		Note(padRight("Area ID", 15, " ") .. "Area Name")
		Note("-------        ---------")
		for i = 1, #mapTable do
			local AreaName = parse_urls(mapTable[i].AreaName)
			if AreaName[1] ~= nil then
			Note(padRight(mapTable[i].Runto, 15, " ") .. AreaName[1].Name)
			end
		end
	end	
	
	-- function to toggle visually impaired mode
	function toggle_vi()
		if (GetVariable("ToggleVI") == "1") then
			SetVariable("ToggleVI", "0")
			ColourNote("SteelBlue", "", "Showmap visually impaired mode has been: ", "Red", "", "Disabled")
		else
			SetVariable("ToggleVI", "1")
			ColourNote("SteelBlue", "", "Showmap visually impaired mode has been: ", "Green", "", "Enabled")
		end
		
	end
	
	function toggle_mirror()
		if (GetVariable("ToggleMirror") == "1") then
			SetVariable("ToggleMirror", "0")
			ColourNote("SteelBlue", "", "Showmap mirror listing mode has been: ", "Red", "", "Disabled")
		else
			SetVariable("ToggleMirror", "1")
			ColourNote("SteelBlue", "", "Showmap mirror listing mode has been: ", "Green", "", "Enabled")
		end
	end	
	
	function parse_urls(mapStr)
		local hrefPat = [[href="(.-)"]]
		local linkNamePat = [[<a[^>]->(.-)</a>]]
		local maps = {}
		local matches = {}
		if mapStr == nil or mapStr == "" then
			return
		end
		string.gsub(mapStr, hrefPat, function(match) matches[#matches+1] = match end)
		for i = 1, #matches do
			maps[i] = {
			Url = matches[i]
			}
		end
		matches = {}
		string.gsub(mapStr, linkNamePat, function(match) matches[#matches+1] = match end)

		for i = 1, #matches do
			maps[i].Name = matches[i]
		end
		return maps
	end
	
	function OnPluginInstall()
		local dbFilePath = GetInfo(60) .. "external_maplinks.db"
		local rowCount = 0
		print("")
		ColourNote("SteelBlue", "", "[", "MediumSeaGreen", "", "LOADED", "SteelBlue", "", "] Showmap v" .. showmap_ver .. " by Pwar (", "MediumSeaGreen", "", "showmap help", "SteelBlue", "",")")
		if not file_exists(dbFilePath) then
			ColourNote("red", "", "ERROR: Unable to locate database file " .. dbFilePath)
			ColourNote("red", "", "This probably means you need to reinstall the plugin and ensure external_maplinks.db is in the same folder.")
			return
		end
		if not db then
			db = sqlite3.open(dbFilePath)
			if not sql_table_exists("areamaps") then
				ColourNote("red", "", "ERROR: Found database file but unable to locate table in database. Your database file may be corrupt. You should probably reinstall the plugin.")
				return
			end
			for row in db:nrows("SELECT * FROM areamaps ORDER BY Runto ASC") do
				rowCount = rowCount + 1
				if row["AreaName"] ~= nil then
					mapTable[rowCount] = row
				end
			end
			if mapTable ~= nil then
				ColourNote("SteelBlue", "", "Successfully loaded data for " .. #mapTable .. " areas from the database.")
				print("")
			end
		end
	end
	
	------ Utils ------
	function padRight(text, length, padChar)
		local padding = length - string.len(text)
		for i = 1, padding do
			text = text .. padChar
		end
		return text
	end
	
	function file_exists(name)
		local f=io.open(name,"r")
		if f~=nil then io.close(f) return true else return false end
	end
	
	------ SQL Utils ------
	function sql_table_exists(table)
		for row in db:nrows("SELECT * FROM sqlite_master WHERE type = 'table' AND name = '" .. table .. "'") do
			return true
		end
		return false
	end

	function sql_check (query)
	   local code = db:exec(query)
	   if code ~= sqlite3.OK and    -- no error
	      code ~= sqlite3.ROW and   -- completed OK with another row of data
	      code ~= sqlite3.DONE then -- completed OK, no more rows
		 local err = db:errmsg ()  -- the rollback will change the error message
		 err = err.."\n\nCODE: "..code.."\nQUERY: "..query.."\n"
		 db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
		 error (err, 3)            -- show error in caller's context
	   end
	   return code
	end
	 
	function fixsql(s)
		if s then
			return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
		else
			return "NULL"
		end
	end

	function reload()
		ColourNote("SteelBlue", "", "Reloading showmap")
		Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
	end

	function update_maps_list()
		async.doAsyncRemoteRequest(MAP_LINKS, update_maps_list_callback, "HTTPS")
	end

	function html_decode(html)
		html = string.gsub(html, '&lt;', '<')
		html = string.gsub(html, '&gt;', '>')
		html = string.gsub(html, '&amp;', '&')
		return html
	end

	function update_maps_list_callback(retval, page, status, headers, full_status, request_url)
		if status ~= 200 then
			ColourNote("red", "", "Could not download maps json")
		else
			ColourNote("SteelBlue", "", "Successfully downloaded maps json page. Updating map data")
			local map_data = string.match(page, "<pre>(.+)</pre>")
			map_data = html_decode(map_data)
			local decoded = json.decode(map_data)
			update_maps_from_live_data(decoded)
		end
	end

	function update_maps_from_live_data(map_data)
		operations = {
			"BEGIN TRANSACTION;",
			"DELETE FROM areamaps;"
		}

		if map_data.data then
			map_data = map_data.data
		end

		for i, area_data in ipairs(map_data) do
			if area_data[1] ~= "Area" then
				table.insert(operations, string.format([[
					INSERT INTO areamaps (AreaName, Runto, Builder, `From`, `To`, Lock, Goal, Maps, Maps2)
					VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s);
					]],
					fixsql(area_data[1]),
					fixsql(area_data[4]),
					fixsql(area_data[5]),
					fixsql(area_data[6]),
					fixsql(area_data[7]),
					fixsql(area_data[8]),
					fixsql(area_data[9]),
					fixsql(area_data[2]),
					fixsql(area_data[3]))
				)
			end
		end
		table.insert(operations, "COMMIT;")
		db:exec(table.concat(operations, ""))
		db:close_vm()
		ColourNote("SteelBlue", "", "Updated map data")
		reload()
	end
]]>
</script> 

</muclient>
