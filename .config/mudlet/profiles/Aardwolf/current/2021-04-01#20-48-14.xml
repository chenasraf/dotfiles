<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<HostPackage>
		<Host autoClearCommandLineAfterSend="no" HighlightHistory="yes" printCommand="yes" USE_IRE_DRIVER_BUGFIX="yes" mUSE_FORCE_LF_AFTER_PROMPT="no" mUSE_UNIX_EOL="no" mNoAntiAlias="no" mEchoLuaErrors="no" runAllKeyMatches="no" AmbigousWidthGlyphsToBeWide="auto" mRawStreamDump="no" mIsLoggingTimestamps="no" logDirectory="" logFileName="" logFileNameFormat="yyyy-MM-dd#HH-mm-ss" mAlertOnNewData="yes" mFORCE_NO_COMPRESSION="no" mFORCE_GA_OFF="no" mFORCE_SAVE_ON_EXIT="yes" mEnableGMCP="yes" mEnableMSSP="yes" mEnableMSP="yes" mEnableMSDP="no" mMapStrongHighlight="no" mLogStatus="no" mEnableSpellCheck="yes" mEnableUserDictionary="yes" mUseSharedDictionary="no" mAcceptServerGUI="yes" mAcceptServerMedia="yes" mMapperUseAntiAlias="yes" mMapperShowRoomBorders="yes" mFORCE_MXP_NEGOTIATION_OFF="no" mFORCE_CHARSET_NEGOTIATION_OFF="no" enableTextAnalyzer="no" mRoomSize="0.5" mLineSize="10.0" mBubbleMode="no" mMapViewOnly="yes" mShowRoomIDs="no" mShowPanel="yes" mHaveMapperScript="no" mEditorAutoComplete="yes" mEditorTheme="Mudlet" mEditorThemeFile="Mudlet.tmTheme" mThemePreviewItemID="-1" mThemePreviewType="" mSearchEngineName="" mTimerSupressionInterval="" mUseProxy="no" mProxyAddress="" mProxyPort="0" mProxyUsername="" mProxyPassword="" mSslTsl="no" mSslIgnoreExpired="no" mSslIgnoreSelfSigned="no" mSslIgnoreAll="no" mDiscordAccessFlags="3071" mRequiredDiscordUserName="" mRequiredDiscordUserDiscriminator="" mSGRCodeHasColSpaceId="no" mServerMayRedefineColors="no" playerRoomPrimaryColor="#ffff0000" playerRoomSecondaryColor="#ffffffff" playerRoomStyle="0" playerRoomOuterDiameter="120" playerRoomInnerDiameter="70" CompactInputLine="no" mDoubleClickIgnore="&quot;'" EditorSearchOptions="0" DebugShowAllProblemCodepoints="no">
			<name>Aardwolf</name>
			<mInstalledPackages>
				<string>deleteOldProfiles</string>
				<string>run-lua-code-v4</string>
				<string>echo</string>
				<string>MAG_110</string>
				<string>generic_mapper</string>
			</mInstalledPackages>
			<url>aardmud.org</url>
			<serverPackageName>nothing</serverPackageName>
			<serverPackageVersion>-1</serverPackageVersion>
			<port>4000</port>
			<borderTopHeight>0</borderTopHeight>
			<borderBottomHeight>176</borderBottomHeight>
			<borderLeftWidth>7</borderLeftWidth>
			<borderRightWidth>332</borderRightWidth>
			<wrapAt>100</wrapAt>
			<wrapIndentCount>0</wrapIndentCount>
			<mFgColor>#c0c0c0</mFgColor>
			<mBgColor>#000000</mBgColor>
			<mCommandFgColor>#717100</mCommandFgColor>
			<mCommandBgColor>#000000</mCommandBgColor>
			<mCommandLineFgColor>#808080</mCommandLineFgColor>
			<mCommandLineBgColor>#000000</mCommandLineBgColor>
			<mBlack>#000000</mBlack>
			<mLightBlack>#808080</mLightBlack>
			<mRed>#800000</mRed>
			<mLightRed>#ff0000</mLightRed>
			<mBlue>#000080</mBlue>
			<mLightBlue>#0000ff</mLightBlue>
			<mGreen>#008000</mGreen>
			<mLightGreen>#00ff00</mLightGreen>
			<mYellow>#808000</mYellow>
			<mLightYellow>#ffff00</mLightYellow>
			<mCyan>#008080</mCyan>
			<mLightCyan>#00ffff</mLightCyan>
			<mMagenta>#800080</mMagenta>
			<mLightMagenta>#ff00ff</mLightMagenta>
			<mWhite>#c0c0c0</mWhite>
			<mLightWhite>#ffffff</mLightWhite>
			<mDisplayFont>Bitstream Vera Sans Mono,14,-1,5,50,0,0,0,1,0</mDisplayFont>
			<mCommandLineFont>Bitstream Vera Sans Mono,14,-1,5,50,0,0,0,0,0</mCommandLineFont>
			<mCommandSeparator>;;</mCommandSeparator>
			<commandLineMinimumHeight>30</commandLineMinimumHeight>
			<mFgColor2>#c0c0c0</mFgColor2>
			<mBgColor2>#000000</mBgColor2>
			<mRoomBorderColor>#c0c0c0</mRoomBorderColor>
			<mBlack2>#000000</mBlack2>
			<mLightBlack2>#808080</mLightBlack2>
			<mRed2>#800000</mRed2>
			<mLightRed2>#ff0000</mLightRed2>
			<mBlue2>#000080</mBlue2>
			<mLightBlue2>#0000ff</mLightBlue2>
			<mGreen2>#008000</mGreen2>
			<mLightGreen2>#00ff00</mLightGreen2>
			<mYellow2>#808000</mYellow2>
			<mLightYellow2>#ffff00</mLightYellow2>
			<mCyan2>#008080</mCyan2>
			<mLightCyan2>#00ffff</mLightCyan2>
			<mMagenta2>#800080</mMagenta2>
			<mLightMagenta2>#ff00ff</mLightMagenta2>
			<mWhite2>#c0c0c0</mWhite2>
			<mLightWhite2>#ffffff</mLightWhite2>
			<mSpellDic>en_US</mSpellDic>
			<mLineSize>10.0</mLineSize>
			<mRoomSize>0.5</mRoomSize>
			<mMapInfoContributors>
				<mapInfoContributor>Short</mapInfoContributor>
			</mMapInfoContributors>
			<stopwatches />
		</Host>
	</HostPackage>
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>MAG_110</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>MAG_110</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>MAG</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Sound Alerts</name>
					<script>
-- Optional:
  -- Lasertag: The lasertag game will close in 1 minute.

-- this is workaround for know Mudlet's issue (requires linux)
-- (normally you would just use play sound check box on the right hand side)
if "linux" == getOS() then 
	os.execute("aplay /usr/share/sounds/alsa/Front_Center.wav")
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile>/usr/share/sounds/alsa/Front_Center.wav</mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(QUEST: You may now quest again\.)$</string>
						<string>Global Quest: See 'Help Global Quests'</string>
						<string>Use 'qreset self' to reset your quest time to 1 minute.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Auto Re-SpellUp</name>
					<script>su.reSpellUpMe()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>{affoff}</string>
						<string>{recoff}</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Gag/Delete Lines</name>
					<script>deleteLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>99</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You have set your character to receive no experience points!$</string>
						<string>^&lt;MAPSTART&gt;$</string>
						<string>^&lt;MAPEND&gt;$</string>
						<string>^{stats}</string>
						<string>^--&gt; TICK &lt;--</string>
						<string>^{affon}</string>
						<string>^{affoff}</string>
						<string>^{recoff}</string>
						<string>^{sfail}</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Highlighting</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>99</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>room graffiti</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#aa5500</mFgColor>
						<mBgColor>#343434</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>\(G\)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>other exits</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#3c005a</mFgColor>
						<mBgColor>#919148</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(other)\]$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>quest target</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#d800d8</mFgColor>
						<mBgColor>#0b0b0b</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>\[TARGET\]$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>{.*start}/{.*end} keyword</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#0000ff</mFgColor>
						<mBgColor>#161616</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^{.*end}$</string>
							<string>^{.*start}$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>spell failed</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ffffff</mFgColor>
						<mBgColor>#000000</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You lost your concentration while trying to cast .*$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>flee</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#c3c3c3</mFgColor>
						<mBgColor>#2a2a2a</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^((.*)has fled!)$</string>
							<string>You flee from combat!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ice Age - qreset self</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Use 'qreset self' to reset your quest time to 1 minute.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Re-Arm</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>disarm</name>
						<script>
-- TODO try to use full name (need to amend regex)
--send("wiel '" .. matches[3] .. "'")

send("get all")
send("wiel " .. matches[3])
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#55ffff</mFgColor>
						<mBgColor>#000000</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*DISARMS you and sends your.* )(.*)( flying!)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>overpower</name>
						<script>
-- TODO see note on disarm

send("wiel " .. matches[3])
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*You stop wielding.* )(.*)( in your primary hand.!)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture Windows</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>99</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Chat Log</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>return AConf.Enabled.ChatLog</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>4</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>communication</name>
							<script>
MAGU.selectCaptured(3)
MAGU.moveSelected(MAG.name_cl, true)
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^()({say}.*)$</string>
								<string>^({tell})(.*)$</string>
								<string>^({chan ch=[^}]*})(.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>remote socials</name>
							<script>
-- only way how to detect remote socials is to check color
selectString(matches[2],1)
r,g,b = getFgColor()
if r==0 and g==128 and b==128 then
	MAGU.selectCaptured()
	MAGU.moveSelected(MAG.name_cl, true)
end
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>99</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([*](.*))$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>various info</name>
							<script>
MAGU.selectCaptured(3)
MAGU.moveSelected(MAG.name_cl, true)
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^()(INFO: .*)$</string>
								<string>^()(Global Quest: .*)$</string>
								<string>^()(Lasertag: .*)$</string>
								<string>^()(WARFARE: .*)$</string>
								<string>^()(GENOCIDE: .*)$</string>
								<string>^()(RAIDINFO: .*)$</string>
								<string>^()(DUEL: .*)$</string>
								<string>^()((.*) has challenged you to a duel[.])$</string>
								<string>^()(Remort Auction:.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Extra Info</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>return AConf.Enabled.ExtraInfo</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>4</integer>
						</regexCodePropertyList>
						<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Quests</name>
							<script></script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList />
							<regexCodePropertyList />
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>Quest ready</name>
								<script>
MAGU.clear(MAG.name_ei)
MAGU.selectCaptured()
MAGU.copySelected(MAG.name_ei, true)
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(QUEST: You may now quest again\.)$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>start of quest</name>
								<script>
if
	table.contains(AConf.Questors, multimatches[1][2]) and
	table.contains(AConf.Questors, multimatches[2][2]) and
	table.contains(AConf.Questors, multimatches[3][2])
then

	MAGU.clear(MAG.name_ei)
	MAGU.echo(MAG.name_ei, multimatches[1][4] .. "\n")
	MAGU.echo(MAG.name_ei, "   " .. multimatches[2][4] .. "\n")
	MAGU.echo(MAG.name_ei, "   " .. multimatches[3][4] .. "\n\n")

	temp_timer_quest = os.time()

	MAG.sa_questTime = multimatches[6][3]

end
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>6</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(.*)( tells you 'Seek )(.*)( out somewhere in the vicinity')$</string>
									<string>^(.*)( tells you 'of )(.*)( which is in the general area')$</string>
									<string>^(.*)( tells you 'of )(.*)([.]')$</string>
									<string>^$</string>
									<string>^(.*) tells you 'Good luck (.*)\. Return safely!'</string>
									<string>^(.*) tells you 'You have (.*) minutes to complete your quest\.'</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>quest mob killed</name>
								<script>
MAGU.selectCaptured()
MAGU.moveSelected(MAG.name_ei, true)
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>99</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^Return to the questmaster before your time runs out[.]$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>end of quest</name>
								<script>
-- Questor tells you 'As a reward, I am giving you 15 quest points and 2567 gold.'

if table.contains(AConf.Questors, matches[2]) then

	local questTime = os.difftime(os.time(), (temp_timer_quest or 0))
	MAGU.echo(MAG.name_ei, "Quest time: " .. questTime .. "s\n\n")

	MAGU.selectCaptured(4)
	MAGU.copySelected(MAG.name_ei)

	-- update quest time
	if MAG.sa_questTime then
		MAG.sa_questTime = 30
		MAG.updateStatusArea()
	end

end
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>8</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(.*)( tells you ')(As a reward, I am giving you (.*) quest points and (.*) gold[.])'$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
								<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
									<name>Items</name>
									<script>
--You get lucky and gain an extra 111 quest points.
--** You gain a bonus training session **   ( 111 training sessions )
--** You gain a bonus 111 practices **      (** You gain a bonus practice ** )
--** You gain a bonus trivia point! **
--You gain an extra 2 quest points 'MCCP Bonus'. 

MAGU.selectCaptured(3)
MAGU.copySelected(MAG.name_ei)
</script>
									<triggerType>0</triggerType>
									<conditonLineDelta>8</conditonLineDelta>
									<mStayOpen>0</mStayOpen>
									<mCommand></mCommand>
									<packageName></packageName>
									<mFgColor>#ff0000</mFgColor>
									<mBgColor>#ffff00</mBgColor>
									<mSoundFile></mSoundFile>
									<colorTriggerFgColor>#000000</colorTriggerFgColor>
									<colorTriggerBgColor>#000000</colorTriggerBgColor>
									<regexCodeList>
										<string>^()(You get lucky and gain an extra (.*) quest points[.])$</string>
										<string>^()([*][*] You gain a bonus (.*)training sessions? [*][*])</string>
										<string>^()([*][*] You gain a bonus (.*)practices? [*][*])</string>
										<string>^()([*][*] You gain a bonus trivia point! [*][*])</string>
										<string>^()(You gain an extra 2 quest points 'MCCP Bonus'[.])$</string>
									</regexCodeList>
									<regexCodePropertyList>
										<integer>1</integer>
										<integer>1</integer>
										<integer>1</integer>
										<integer>1</integer>
										<integer>1</integer>
									</regexCodePropertyList>
								</Trigger>
								<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
									<name>Items (with questor name)</name>
									<script>
--&lt;questor name&gt; tells you 'I am also giving you 111 quest points tier bonus.'

if table.contains(AConf.Questors, matches[2]) then
	MAGU.selectCaptured()
	MAGU.copySelected(MAG.name_ei)
end
</script>
									<triggerType>0</triggerType>
									<conditonLineDelta>99</conditonLineDelta>
									<mStayOpen>0</mStayOpen>
									<mCommand></mCommand>
									<packageName></packageName>
									<mFgColor>#ff0000</mFgColor>
									<mBgColor>#ffff00</mBgColor>
									<mSoundFile></mSoundFile>
									<colorTriggerFgColor>#000000</colorTriggerFgColor>
									<colorTriggerBgColor>#000000</colorTriggerBgColor>
									<regexCodeList>
										<string>^(.*)( tells you 'I am also giving you )(.*)(quest points? tier bonus[.]')</string>
									</regexCodeList>
									<regexCodePropertyList>
										<integer>1</integer>
									</regexCodePropertyList>
								</Trigger>
							</TriggerGroup>
						</TriggerGroup>
						<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>GQs &amp; CPs</name>
							<script>
-- TODO still missing string for items

-- You still have to kill 1 * a messenger (Central square)
-- You still have to kill 2 * a messenger (Central square)
-- You still have to kill 4 * a messenger (Central square)
-- (followed by blank line)
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>99</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList />
							<regexCodePropertyList />
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>mobs/items to info</name>
								<script>
-- TODO get string for cp/gq items

if not temp_need_gq_sep then
	temp_need_gq_sep = true
	MAGU.clear(MAG.name_ei)
end

-- You still have to kill 1 * a messenger (Central square)
MAGU.echo(MAG.name_ei, matches[2] .. "\n")
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^You still have to kill (.*)$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>add final blank line to info</name>
								<script>
if temp_need_gq_sep then
	temp_need_gq_sep = false
	MAGU.echo(MAG.name_ei, "\n")
end
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>gq joined</name>
								<script></script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand>gq i</mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>You have now joined the quest. See 'help gquest' for available commands.</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>0</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>gq start or gq mob killed</name>
								<script></script>
								<triggerType>0</triggerType>
								<conditonLineDelta>99</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand>gq c</mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>Global Quest: Use 'gquest info' to see the targets.</string>
									<string>Congratulations, that was one of the GLOBAL QUEST mobs!</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>0</integer>
									<integer>0</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>cp start or cp mob killed</name>
								<script></script>
								<triggerType>0</triggerType>
								<conditonLineDelta>99</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand>cp c</mCommand>
								<packageName></packageName>
								<mFgColor>#000018</mFgColor>
								<mBgColor>#660099</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>Commander Barcett tells you 'Good luck in your campaign!'</string>
									<string>Congratulations, that was one of your CAMPAIGN mobs!</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>0</integer>
									<integer>0</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>end of cp</name>
								<script>
MAGU.clear(MAG.name_ei)
MAGU.echo(MAG.name_ei, "\nCP completed - WELL DONE")

-- TODO copy some results there
--[[
--------------------------------------------------------------
CONGRATULATIONS! You have completed your campaign.
                 Reward of 33 quest points added.
                 Reward of 5222 gold coins added.
You will have to level before you can go on another campaign.
--------------------------------------------------------------
--]]
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>CONGRATULATIONS! You have completed your campaign.</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>0</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>end of gq</name>
								<script>
MAGU.clear(MAG.name_ei)
MAGU.echo(MAG.name_ei, "\nYou won GQ - WELL DONE")

-- TODO same as cp
-- plus you LOST message

--[[
CONGRATULATIONS! You were the first to complete this quest!
Reward of 21 quest points added.
Reward of 4 practice sessions added.
Reward of 1000 gold coins added.
You may win 2 more gquests at this level.
--]]
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>99</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>CONGRATULATIONS! You were the first to complete this quest!</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>0</integer>
								</regexCodePropertyList>
							</Trigger>
						</TriggerGroup>
						<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Account Info</name>
							<script>
MAGU.echo(MAG.name_ei)
MAGU.selectCaptured()
MAGU.copySelected(MAG.name_ei)
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>99</conditonLineDelta>
							<mStayOpen>8</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^Gold on hand(.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>Items</name>
								<script>
-- TODO this is not holding BID information yet

MAGU.selectCaptured()
MAGU.copySelected(MAG.name_ei)
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^Gold in the bank(.*)$</string>
									<string>^Net Worth(.*)$</string>
									<string>^Trivia Points(.*)$</string>
									<string>^Quest Points(.*)$</string>
									<string>^Gold Committed(.*)$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
						</TriggerGroup>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Mini Map</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>return AConf.Enabled.MiniMap</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>4</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Map Start</name>
							<script>
MAGU.clear(MAG.name_mm)
temp_mapstarted = true
temp_mapLines = 1
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>99</conditonLineDelta>
							<mStayOpen>19</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^&lt;MAPSTART&gt;$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>Map End</name>
								<script>temp_mapstarted = false</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^&lt;MAPEND&gt;$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>Map Line</name>
								<script>
if temp_mapstarted then
	if temp_mapLines &gt; 2 then
		-- move line to map
		MAGU.selectCaptured()
		MAGU.moveSelected(MAG.name_mm)
	elseif temp_mapLines == 1 then
		-- first line = rest of the name
		MAG.sa_roomName = matches[1]
		temp_mapLines = 2
		deleteLine()
	elseif temp_mapLines == 2 then
		-- second line = rest of the name
		MAG.sa_roomName = MAG.sa_roomName .. matches[1]
		temp_mapLines = 3
		deleteLine()
	end
end
</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>99</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(.*)$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Status Area</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>return AConf.Enabled.StatusArea</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>4</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Status update</name>
							<script>MAG.updateStatusArea(matches[2])
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>99</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^{stats}(.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>MUD Tick</name>
							<script>
if AConf.Enabled.TickTimer then
	MAG.tick.start()
end

if matches[5] then
	MAG.sa_questTime = matches[5]
end

-- update monitor after each tick
send(" ")
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#000035</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(--&gt; TICK &lt;--)( \((.*) Qt: (\d+)(, T:.*)?\))?</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Hunger</name>
							<script></script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList />
							<regexCodePropertyList />
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>full</name>
								<script>MAG.sa_hunger = nil</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>You are now full.</string>
									<string>^Hunger : .*% - Full$</string>
									<string>^\| To Lvl : \[.*\] \| Age      : \[.*\] \| Hunger : .*  Full        \|$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>3</integer>
									<integer>1</integer>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>hungry</name>
								<script>MAG.sa_hunger = "&lt;yellow&gt;hungry"</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>## You start to feel hungry.</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>3</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>very hungry</name>
								<script>MAG.sa_hunger = "&lt;red&gt;hungry"</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>## You are very hungry; your healing is reduced.</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>3</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>startving</name>
								<script>MAG.sa_hunger = "&lt;red&gt;STARVING"</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>76</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>## You are starving; your healing is greatly reduced.</string>
									<string>Hunger : 0% - Starving</string>
									<string>^\| To Lvl : \[.*\] \| Age      : \[.*\] \| Hunger : 0   Starving    \|$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>3</integer>
									<integer>3</integer>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
						</TriggerGroup>
					</TriggerGroup>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Statistics</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>return AConf.Enabled.Statistics</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>4</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>kills</name>
						<script>stats.addKill()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You receive (.*) experience points[.]$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>exp</name>
						<script>
stats.addExp(matches[2])

-- You receive 103 experience points.
-- You receive 103 bonus experience points in honor of Maxx reaching superhero.
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You receive (.*) experience points[.]$</string>
							<string>^You receive (.*) bonus experience points (.*)[.]$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>gold</name>
						<script>
stats.addGold(matches[3])

-- You get 3 gold coins from the ashen-grey corpse of a jumping cholla.
-- Ayla gives you 4 gold coins for the battered corpse of a sand snake.
-- A QuestoR tells you 'As a reward, I am giving you 12 quest points and 2579 gold.'
-- The treasure of gold coins crumbles into 40 gold pieces.
-- You sell 5 * a sapphire gem to Peto, the bard hall cook for 98 gold.
-- Reward of 1000 gold coins added.


-- TODO
--   group share
	--You get 10 gold coins from the perforated corpse of Breznar and Grenup.
	--You share 10 gold coins with 1 other member. Your share is 5 gold.
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^()You get (.*) gold coins? from (.*) corpse of (.*)[.]$</string>
							<string>^()Ayla gives you (.*) gold coins? for (.*)[.]$</string>
							<string>'As a reward, I am giving you (.*) quest points and (.*) gold.'</string>
							<string>^(.*) crumbles into (.*) gold pieces?[.]$</string>
							<string>^You sell (.*) for (.*) gold[.]$</string>
							<string>^()Reward of (.*) gold coins? added[.]$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>qp</name>
						<script>
stats.addQp(matches[2])

-- A QuestoR tells you 'As a reward, I am giving you 12 quest points and 2579 gold.'
-- You gain an extra 2 quest points 'MCCP Bonus'.
-- You get lucky and gain an extra 2 quest points.
-- 3 quest points awarded.
-- Reward of 20 quest points added.
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>'As a reward, I am giving you (.*) quest points and (.*) gold.'</string>
							<string>^You gain an extra (.*) quest points 'MCCP Bonus'[.]$</string>
							<string>^You get lucky and gain an extra (.*) quest points[.]$</string>
							<string>^(.*) quest points awarded[.]$</string>
							<string>^Reward of (.*) quest points added[.]$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Barter Watcher</name>
					<script>-- TODO idea copy and paste "sell line" to main window</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>return AConf.Enabled.BarterWatcher</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>4</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Auction</name>
						<script>
local out = "bid " .. matches[2]
if MAG.c102.afk() then
	out = "afk;; " .. out .. " ;; afk"
end
send(out)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Auction: .* is auctioning .* \(Level .*, Num (.*)\)\. Current bid is .*\.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Market</name>
						<script>
local out = "lbid " .. matches[2]
if MAG.c102.afk() then
	out = "afk;; " .. out .. " ;; afk"
end
send(out)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Market: Bid of .* on .* \(Level .*, Num (.*)\)</string>
							<string>Market: .* is selling .* \(Level .*, Num (.*)\)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Rauction</name>
						<script>
local out = "rbid " .. matches[2]
if MAG.c102.afk() then
	out = "afk;; " .. out .. " ;; afk"
end
send(out)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Remort Auction: .* is selling a level .* \(Num (.*)\)\.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>MAG Startup - New Connection</name>
					<script>MAG.avatarSetup()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>3</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>#################  /                                      ; #################</string>
						<string>###############  /                                       ; ##################</string>
						<string>-----------------------------------------------------------------------------</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>generic_mapper</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>generic_mapper</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>onNewLine Trigger</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>raiseEvent("onNewLine")</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>4</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Tab Trigger</name>
				<script>local text = line
local pos = selectString("\t",1)
while pos ~= -1 do
	replace(string.rep(" ",8 - math.fmod(pos,8)))
	pos = selectString("\t",1)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>\t</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>English Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(?i)^\s*\[\s*Exits:\s*(.*)\]</string>
						<string>^\s*There (?:is|are) \w+ (?:visible|obvious) exit[s]?:\s*(.*)</string>
						<string>^\[?\s*(?:[Vv]isible|[Oo]bvious) (?:[Pp]ath|[Ee]xit)[s]?(?: is| are)?:?\s*(.*)\]?</string>
						<string>^\s*You see[\w\s]* exit[s]? leading (.*)</string>
						<string>Exits:\s*(.*)</string>
						<string>There are no obvious exits.</string>
						<string>^\s*The (?:only )?obvious exit[s]? (?:is|are):? (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Failed Move Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:Alas, )?[Yy]ou can(?:no|')t (?:go|move) .*$</string>
						<string>^The .+ (?:is|seems to be) closed.$</string>
						<string>.+ (?:is not going to|will not) let you pass.$</string>
						<string>^That exit is blocked.$</string>
						<string>^You are blocked by .*$</string>
						<string>^There is no exit in that direction.$</string>
						<string>^The .* is locked.$</string>
						<string>^Alas, you cannot go that way\.\.\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Vision Fail Trigger</name>
					<script>raiseEvent("onVisionFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^It is pitch black...</string>
						<string>^It(?:'s| is) too dark</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Forced Move Trigger</name>
					<script>raiseEvent("onForcedMove",matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Carefully getting your bearings, you set off (\w+) toward your goal.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Multi-Line Exits Trigger</name>
					<script>map.prompt.exits = ""</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>1</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(?i:^(obvious|visible) exits:)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Exit Line Trigger</name>
						<script>map.prompt.exits = map.prompt.exits .. ", " .. string.trim(matches[2])
setTriggerStayOpen("English Multi-Line Exits Trigger",1)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^([\w\s]+)\s*: [\w\s]+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Russian Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s*\[\s*Выходы:\s*(.*)\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Failed Move Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Извини, но ты не можешь туда идти.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russion Vision Fail Trigger</name>
					<script>raiseEvent("onVisionFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Здесь слишком темно ...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Chinese Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chinese Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s*这里明显的方向有 (.*)。</string>
						<string>^\s*这里明显的出口有 (.*)。</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chinese Failed Movement Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>你又渴又饿，浑身无力，根本就走不动路。</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>deleteOldProfiles</name>
			<script></script>
			<command></command>
			<packageName>deleteOldProfiles</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>delete old profiles</name>
				<script>deleteOldProfiles(matches[3], matches[2])

--Syntax examples: "delete old profiles"  -&gt; deletes profiles older than 31 days
--					"delete old maps 10"	-&gt; deletes maps older than 10 days</script>
				<command></command>
				<packageName></packageName>
				<regex>^delete old (profiles|maps|modules)(?: (\d+))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>run-lua-code-v4</name>
			<script></script>
			<command></command>
			<packageName>run-lua-code-v4</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>run lua code</name>
				<script>local f, e = loadstring("return "..matches[2])
if not f then
  f, e = assert(loadstring(matches[2]))
end

local r =
  function(...)
    if not table.is_empty({...}) then
      display(...)
    end
  end
r(f())</script>
				<command></command>
				<packageName></packageName>
				<regex>^lua (.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>echo</name>
			<script></script>
			<command></command>
			<packageName>echo</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>`echo</name>
				<script>local s = matches[2]

s = string.gsub(s, "%$", "\n")
feedTriggers("\n" .. s .. "\n")
echo("\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>`echo (.+)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>MAG_110</name>
			<script></script>
			<command></command>
			<packageName>MAG_110</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>MAG</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Lua helpers</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Run Lua code with ! prefix</name>
						<script>
-- USAGE:  
--   !commnad
--
-- EXAMPLE:
--   !echo("Hello from Lua")

local f,e = loadstring("return "..matches[2])
if not f then 
	f,e = assert(loadstring(matches[2]))
end 

local r = f()
if r then display(r) end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^!(.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Repeat command</name>
						<script>
-- USAGE: 
--   rep N command
--
-- EXAMPLE:
--   rep 3 hey
-- will send following to mud
--   hey
--   hey
--   hey

--utils.startGagEmptyLines()
utils.hidePrompt()
for i = 1, tonumber(matches[2]) do
	send(matches[3])
end
--utils.stopGagEmptyLinesOn("{repeat-end}")
send("echo {repeat-end}", false)
utils.showPrompt()
</script>
						<command></command>
						<packageName></packageName>
						<regex>^rep (\d+) (.*)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Loop with index</name>
						<script>
-- USAGE:  
--   loo 9 pref, suf
--   loop 9 pref, suf
--
-- EXAMPLE:
--   loo 3 where, ant
-- will send following to mud
--   where 1.ant
--   where 2.ant
--   where 3.ant

--utils.startGagEmptyLines()
utils.hidePrompt()
for i = 1, tonumber(matches[2]) do
	send(matches[3] .. " " .. i .. "." .. matches[4])
end
--utils.stopGagEmptyLinesOn("{repeat-end}")
send("echo {loop-end}", false)
utils.showPrompt()
</script>
						<command></command>
						<packageName></packageName>
						<regex>^loop? (\d+) (.*), (.*)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Find string in buffer</name>
						<script>
-- usage:
--   bfind rat
--   bfind[2] rat
--   bdind ^lua
--   bfind[10] quest


-- config
local bfindMark = "bfind"  -- should be same as alias
local hist = 7500
local minL = 0

-- getting lines
if getLineCount() &gt; hist then
	minL = getLineCount() - hist
end
local data = getLines(minL, getLineCount())

-- prepare for search
local pattern = string.genNocasePattern(matches[5])
local delta = nil
if matches[4] then 
	delta = tonumber(matches[4])
end

-- looking for pattern in history
for i,line in ipairs(data) do
	local match = string.findPattern(line, pattern)
	if match then
		if not string.starts(line, bfindMark) then
			local hline = string.gsub(line, pattern, "&lt;purple&gt;" .. match .. "&lt;lime_green&gt;")	
			-- printing lines before match
			if delta then
 				for ii=delta,1,-1 do 
					if (i-ii) &gt;= 1 then
						cecho(string.format("&lt;black&gt;%s &lt;dark_green&gt;%4d: &lt;lime_green&gt;%s\n", bfindMark, (i-ii), data[i-ii]))
					end
				end
			end
			-- printing match line
			cecho(string.format("&lt;black&gt;%s &lt;medium_sea_green&gt;%4d: &lt;lime_green&gt;%s\n", bfindMark, i, hline))
			-- printing lines after match
			if delta then
				for ii=1,delta do 
					if (i+ii) &lt;= hist then
						cecho(string.format("&lt;black&gt;%s &lt;dark_green&gt;%4d: &lt;lime_green&gt;%s\n", bfindMark, (i+ii), data[i+ii]))
					end
				end
				-- printing separator
				cecho(string.format("&lt;black&gt;%s&lt;dark_slate_grey&gt;-----\n", bfindMark))
			end
		end
	end
end

-- reseting color and adding final blank line
resetFormat()
echo("\n")
</script>
						<command></command>
						<packageName></packageName>
						<regex>^bfind((\[(\d+)\])?) (.*)$</regex>
					</Alias>
				</AliasGroup>
				<Alias isActive="yes" isFolder="no">
					<name>recall, eat and sleep</name>
					<script>send(AConf.Actions.recallEatAndSleep)</script>
					<command></command>
					<packageName></packageName>
					<regex>^bed$</regex>
				</Alias>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Info</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>list learned spells</name>
						<script></script>
						<command>spells learned</command>
						<packageName></packageName>
						<regex>^lll$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>list combat spells</name>
						<script></script>
						<command>spells combat</command>
						<packageName></packageName>
						<regex>^ll$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>consider all</name>
						<script></script>
						<command>con all</command>
						<packageName></packageName>
						<regex>^ca$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>listen to</name>
						<script>send("listen " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^ls( .*)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>market search 0 1</name>
						<script></script>
						<command>market search 0 1</command>
						<packageName></packageName>
						<regex>^ms$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>lastkills</name>
						<script>send("lastkills " .. (matches[2] or "20"))</script>
						<command></command>
						<packageName></packageName>
						<regex>^lk( .*)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Quests</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>quest request</name>
						<script>
if not MAG.c102.combat() and not MAG.c102.afk() then
	if MAG.c102.sleepingOrResting() then
		send("wake")
	end
	send(AConf.Actions.usePortalToRecall .. " ;; " .. AConf.Actions.runToQuestor .. " ;; q r")
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^qr$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>quest complete</name>
						<script>
if not MAG.c102.combat() and not MAG.c102.afk() then
	send(AConf.Actions.usePortalToRecall .. " ;; " .. AConf.Actions.runToQuestor .. " ;; q c")
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^qc$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Items</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>get all</name>
						<script>send("get all" .. (matches[2] or ""))</script>
						<command></command>
						<packageName></packageName>
						<regex>^ga( .*)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>drop all</name>
						<script></script>
						<command>drop all</command>
						<packageName></packageName>
						<regex>^da$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sacrifice all</name>
						<script></script>
						<command>sac all</command>
						<packageName></packageName>
						<regex>^sa$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>wear item</name>
						<script>
-- default 'we' is for going west
send("wear " .. matches[2])
</script>
						<command></command>
						<packageName></packageName>
						<regex>^we( .*)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>keep all keys</name>
						<script></script>
						<command>keep all.key ;; i filter key</command>
						<packageName></packageName>
						<regex>^kk$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>use invisibility ring</name>
						<script></script>
						<command>r 'invis ring' ;; wea 'invis ring' ;; aflag</command>
						<packageName></packageName>
						<regex>^inv$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>use portal to recall</name>
						<script>send(AConf.Actions.usePortalToRecall)</script>
						<command></command>
						<packageName></packageName>
						<regex>^[.]$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Hunt</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>where</name>
						<script>send("where" .. (matches[2] or ""))</script>
						<command></command>
						<packageName></packageName>
						<regex>^v( .*)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>scan / kill</name>
						<script>send("scan" .. (matches[2] or ""))</script>
						<command></command>
						<packageName></packageName>
						<regex>^x( .*)?( k)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>where all</name>
						<script>
-- USAGE: 
--   va &lt;mob&gt;
--
-- EXAMPLE:
--   va imp
-- will send following to mud
--   where 1.imp
--   where 2.imp
--   ...

utils.startGagEmptyLines()
utils.hidePrompt()
for i = 1, 9 do
	send("where " .. i .. "." .. matches[2])
end
utils.stopGagEmptyLinesOn("{where-all-end}")
send("echo {where-all-end}", false)
utils.showPrompt()
</script>
						<command></command>
						<packageName></packageName>
						<regex>^va (.*)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>hunt all</name>
						<script>
-- USAGE: 
--   ha &lt;mob&gt;
--
-- EXAMPLE:
--   ha imp
-- will send following to mud
--   hunt 1.imp
--   hunt 2.imp
--   ...

utils.startGagEmptyLines()
utils.hidePrompt()
for i = 1, 9 do
	send("hunt " .. i .. "." .. matches[2])
end
utils.stopGagEmptyLinesOn("{hunt-end}")
send("echo {hunt-end}", false)
utils.showPrompt()
</script>
						<command></command>
						<packageName></packageName>
						<regex>^ha (.*)$</regex>
					</Alias>
				</AliasGroup>
				<Alias isActive="yes" isFolder="no">
					<name>Statistics</name>
					<script>
-- You can use following alliases to control statistics
--   stat help
--   stat reset
--   stat print
--   stat hide
--
-- Of following ones if you are lazy to type
--   s ?
--   s r
--   s p
--   s h
if AConf.Enabled.Statistics then
	stats.control(matches[3])
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(stat|s) (help|print|reset|hide|\?|p|r|h)$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>generic_mapper</name>
			<script></script>
			<command></command>
			<packageName>generic_mapper</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Setup Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Show Alias</name>
					<script>map.showMap()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map show$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Find Map Prompt Alias</name>
					<script>map.find_prompt()</script>
					<command></command>
					<packageName></packageName>
					<regex>^find prompt$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Prompt Alias</name>
					<script>-- USE PATTERNS FOR STRING.GSUB
if matches[2] then
  map.make_prompt_pattern(matches[2])
else
  display(map.save.prompt_pattern)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map prompt(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Ignore Alias</name>
					<script>-- USE PATTERNS FOR STRING.GSUB
if matches[2] then
  map.make_ignore_pattern(matches[2])
else
  display(map.save.ignore_patterns)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map ignore(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Debug Alias</name>
					<script>map.configs.debug = not map.configs.debug
map.echo("Map debug set to: " .. (map.configs.debug and "on" or "off"))</script>
					<command></command>
					<packageName></packageName>
					<regex>^map debug$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Update Alias</name>
					<script>map.updateVersion()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map update$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Config Alias</name>
					<script>-- adjust pattern to allow no argument, if no argument show general help about configs
if not matches[2] then
	cecho(map.help.config)
else
  local startStr, endStr = string.match(matches[2],"(.*) ([%w%.]+)")
  local vals = {'on', 'off', 'true', 'false'}
  local modes = {'lazy','simple','normal','complex'}
  if (table.contains(vals, endStr) or tonumber(endStr)) or (startStr == "mode" and table.contains(modes, endStr)) then
  	map.setConfigs(startStr, endStr)
  else
  	map.setConfigs(matches[2])
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map config(?: ([\w\s\.]+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Window Config Alias</name>
					<script>map.setConfigs("map_window",matches[3],matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map window (x|y|w|h|origin|shown)(?: ([\w%]+))?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Translate Config Alias</name>
					<script>map.setConfigs("lang_dirs", {matches[3], matches[4]}, matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map translate (\w+) (\w+) (\w+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Information Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Quick Start Alias</name>
					<script>map.show_help("quick_start")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map basics$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Help Alias</name>
					<script>map.show_help(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map help(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Rooms Alias</name>
					<script>map.echoRoomList(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map rooms (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Areas Alias</name>
					<script>map.echoAreaList()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map areas$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Regular Use Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Me Alias</name>
					<script>map.find_me(nil, nil, nil, true)</script>
					<command></command>
					<packageName></packageName>
					<regex>^map me$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Path Alias</name>
					<script>map.find_path(matches[2],matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map path ([^;]+)(?:\s*;\s*(.+))?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Recall Alias</name>
					<script>map.set_recall()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map recall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Character Alias</name>
					<script>map.character = matches[2]</script>
					<command></command>
					<packageName></packageName>
					<regex>^map character (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Stop Alias</name>
					<script>raiseEvent("mapStop")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map stop$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Map Creation Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Set Room Area Alias</name>
					<script>map.set_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^set area (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Start Mapping Alias</name>
					<script>map.start_mapping(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^start mapping(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Stop Mapping Alias</name>
					<script>map.stop_mapping()</script>
					<command></command>
					<packageName></packageName>
					<regex>^stop mapping$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Shift Room Alias</name>
					<script>map.shift_room(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^shift (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add Portal Alias</name>
					<script>map.set_portal(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^add portal (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Show Moves Alias</name>
					<script>map.show_moves()</script>
					<command></command>
					<packageName></packageName>
					<regex>^show moves$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Clear Moves Alias</name>
					<script>map.clear_moves()</script>
					<command></command>
					<packageName></packageName>
					<regex>^clear moves$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add Door Alias</name>
					<script>map.set_door(matches[2],matches[3],matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^add door (\w+)(?: (none|open|closed|locked))?(?: (yes|no))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Merge Rooms Alias</name>
					<script>map.merge_rooms()</script>
					<command></command>
					<packageName></packageName>
					<regex>^merge rooms$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Mode Alias</name>
					<script>map.set_mode(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map mode (\w+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Room Exit Alias</name>
					<script>map.set_exit(matches[2],matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^set exit (.+) (\d+)</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Map Sharing Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Save Map Alias</name>
					<script>saveMap(getMudletHomeDir() .. "/map.dat")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map save$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Load Map Alias</name>
					<script>map.load_map(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map load(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Import Map Area Alias</name>
					<script>map.import_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map import (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Export Map Area Alias</name>
					<script>map.export_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map export (.*)</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>deleteOldProfiles</name>
			<packageName>deleteOldProfiles</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>deleteOldProfiles script</name>
				<packageName></packageName>
				<script>function deleteOldProfiles(keepdays_arg, delete_folder)
  --[[
  Deletes old profiles/maps/modules in the "current"/"map"/"moduleBackups" folders of the Mudlet home directory.
  The following files are NOT deleted:
  - Files newer than the amount of days specified as an argument to deleteOldProfiles(), or 31 days if not specified.
  - One file for every month before that. Specifically: The first available file of every month prior to this.
  Setting the second argument to true will delete maps instead of profiles. (e.g. deleteOldProfiles(10, true))
  --]]

  -- Ensure correct value is passed for second argument
  assert(type(delete_folder) == "string", "Wrong type for delete_folder; expected string, got " .. type(delete_folder))
  assert(table.contains({"profiles", "maps", "modules"}, delete_folder), "delete_folder must be profiles, maps or modules")

  local keepdays = tonumber(keepdays_arg) or 31
  local profile_table = {}
  local used_last_mod_months = {}
  local slash = (string.char(getMudletHomeDir():byte()) == "/") and "/" or "\\"
  local delnum = 0

  local to_folder = {
    profiles = "current",
    maps = "map",
  }

  local dirpath = delete_folder == "modules"
    and getMudletHomeDir()..slash..".."..slash..".."..slash.."moduleBackups"
    or getMudletHomeDir()..slash..to_folder[delete_folder]

  -- Traverse the profiles folder and create a table of files:
  for filename in lfs.dir(dirpath) do
    if filename~="." and filename~=".." then
      profile_table[#profile_table+1] = {
        name = filename,
        last_mod = lfs.attributes(dirpath..slash..filename, "modification")
      }
    end
  end

  -- Sort the table according to last modification date from old to new:
  table.sort(profile_table, function (a,b) return a.last_mod &lt; b.last_mod end)

  echo(string.format(
    "\nDeleting old %s. Files newer than %d days and one for every month before that will be kept.",
    delete_folder,
    keepdays
  ))

  for i, v in ipairs(profile_table) do
    local days = math.floor(os.difftime(os.time(), v.last_mod) / 86400)
    local last_mod_month = os.date("%Y/%m", v.last_mod)
    if days &gt; keepdays then
      -- For profiles older than X days, check if we already kept a table for this month:
      if not table.contains(used_last_mod_months, last_mod_month) then
        -- If not, do nothing and mark this month as "kept".
        used_last_mod_months[#used_last_mod_months+1] = last_mod_month
      else
        -- Otherwise remove the file:
        local success, errorstring = os.remove(dirpath..slash..v.name)
        if success then
          delnum = delnum + 1
        else
          cecho("\n&lt;red&gt;ERROR: "..errorstring)
        end
      end
    end
  end

  echo(string.format("\nDeletion complete. %d/%d files were removed successfully.", delnum, #profile_table))
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>MAG_110</name>
			<packageName>MAG_110</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Geyser</name>
				<packageName></packageName>
				<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

-- UNCOMMENT EVERYTHING BELOW THIS LINE FOR VERSIONS PRIOR TO 1.1.0
myoldresizer = myoldresizer or handleWindowResizeEvent
function handleWindowResizeEvent()
	raiseEvent("sysWindowResizeEvent")
end</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>GeyserGeyser</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--==================================================
-- Create the Geyser Root Container
--==================================================

--- Create the Geyser namespace.
-- Geyser is considered to be a "container window" for the purposes
-- of default limits for new windows, in fact, it is the root container
-- window, and is the metatable for Geyser.Container. It has the 
-- minimum number of functions needed to behave as a Container.
Geyser = Geyser or {i = 0, x = 0, y = 0}
Geyser.width, Geyser.height = getMainWindowSize()

Geyser.get_x = function () return 0 end
Geyser.get_y = function () return 0 end
Geyser.get_width = function () return getMainWindowSize() end
Geyser.get_height = function () local w,h = getMainWindowSize() return h end
Geyser.name = "Geyser Root Window"
Geyser.__index = Geyser

-- Create the window list for updates
Geyser.windowList = Geyser.windowList or {}

--- Add a window to the list that this container manages.
-- @param window The window to add this container
function Geyser:add (window, cons)
   cons = cons or window -- 'cons' is optional
   
   -- Stop other container from controlling this window
	if window.container then
	   window.container:remove(window)
	end

   -- Assume control of this window
   window.container = self
   self.windowList[window.name] = window
   Geyser.set_constraints(window, cons, self)
   window:reposition()
   window:show()
end

--- Removes a window from the list that it manages
-- @param window The window to remove from this container's
-- windowList
function Geyser:remove (window)
   self.windowList[window.name] = nil
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserUtil</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--- Generate a window name unique to this session.
function Geyser.nameGen (type)
   local index = Geyser.i
   local t = type or "window"
   Geyser.i = Geyser.i + 1
   return "anon_" .. t .. "_" .. index
end

--- Hide all managed windows.
function Geyser.hideAll(type)
   for _,v in pairs(Geyser.windowList) do
      if v.type == type or not type then
         v:hide()
      end
   end
end

--- Show all managed windows.
function Geyser.showAll(type)
   for _,v in pairs(Geyser.windowList) do
      if v.type == type or not type then
         v:show()
      end
   end
end

--- Non-recursive display of an item, because the normal 'display' was
-- causing Mudlet to hang. Not sure why.
function Geyser.display (table)
	echo("------ " .. type(table) .. " ------\n")
	if type(table) == "table" then
		for k,v in pairs(table) do
			echo("'" .. tostring(k) .. "' - " .. tostring(v) .. "\n")
		end
	else
		echo(tostring(table) .. "\n")
	end
end

--- Clone a table, for good fun and profit.
function Geyser.copyTable (table)
	local copy = {}
    if table then
		for k,v in pairs(table) do
			-- do deep copy on a table if it requests one by having the __clone function defined.
			if type(v) == "table" and v.__clone then
				copy[k] = v.__clone()
			else
				copy[k] = v
			end
		end
	end
	return copy
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserColor</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

Geyser.Color = {}

--- Converts color to 3 hex values as a string, no alpha, css style
-- @return The color formatted as a hex string, as accepted by html/css
function Geyser.Color.hex (r,g,b)
   return string.format("#%02x%02x%02x", Geyser.Color.parse(r, g, b))
end

--- Converts color to 4 hex values as a string, with alpha, css style
-- @return The color formatted as a hex string, as accepted by html/css
function Geyser.Color.hexa (r,g,b,a)
   return string.format("#%02x%02x%02x%02x", Geyser.Color.parse(r, g, b, a))
end

--- Converts color to 3 hex values as a string, no alpha, hecho style
-- @return The color formatted as a hex string, as accepted by hecho
function Geyser.Color.hhex (r,g,b)
   return string.format("|c%02x%02x%02x", Geyser.Color.parse(r, g, b))
end

--- Converts color to 4 hex values as a string, with alpha, hecho style
-- @return The color formatted as a hex string, as accepted by hecho
function Geyser.Color.hhexa (r,g,b,a)
   return string.format("|c%02x%02x%02x%02x", Geyser.Color.parse(r, g, b, a))
end

--- Converts color to 3 decimal values as a string, no alpha, decho style
-- @return The color formatted as a decho() style string
function Geyser.Color.hdec (r,g,b)
   return string.format("&lt;%d,%d,%d&gt;", Geyser.Color.parse(r, g, b))
end

--- Converts color to 4 decimal values as a string, with alpha, decho style
-- @return The color formatted as a decho() style string
function Geyser.Color.hdeca (r,g,b,a)
   return string.format("&lt;%d,%d,%d,%d&gt;", Geyser.Color.parse(r, g, b, a))
end

--- Returns 4 color components from (nearly any) acceptable format.  Colors can be
-- specified in two ways.  First: as a single word in english ("purple") or
-- hex ("#AA00FF", "|cAA00FF", or "0xAA00FF") or decimal ("&lt;190,0,255&gt;"). If
-- the hex or decimal representations contain a fourth element then alpha is
-- set too - otherwise alpha can't be set this way.  Second: by passing in
-- distinct components as unsigned integers (e.g. 23 or 0xA7).  When using the
-- second way, at least three values must be passed.  If only three are
-- passed, then alpha is 255.  Third: by passing in a table that has explicit 
-- values for some, all or none of the keys r,g,b, and a.
-- @param red Either a valid string representation or the red component.
-- @param green The green component.
-- @param blue The blue component.
-- @param alpha The alpha component.
function Geyser.Color.parse(red, green, blue, alpha)
   local r,g,b,a = 0,0,0,255

   -- have to have something to set, else can't do anything!
   if not red then
      print("No color supplied.\n")
      return
   end
   
   -- function to return next number
   local next_num = nil
   local base = 10
   -- assigns all the colors, used after we figure out how the color is
   -- represented as a string
   local assign_colors = function ()
                            r = tonumber(next_num(), base)
                            g = tonumber(next_num(), base)
                            b = tonumber(next_num(), base)
                            local has_a = next_num() 
                            if has_a then
                               a = tonumber(has_a, base)
                            end
                         end
   
   -- Check if we were passed a string or table that needs to be parsed, i.e.,
   -- there is only a valid red value, and other params are nil.
   if not green or not blue then
      if type(red) == "table" then
         -- Here just copy over the appropriate values with sensible defaults
         r = red.r or 127
         g = red.g or 127
         b = red.b or 127
         a = red.a or 255
         return r,g,b,a
      elseif type(red) == "string" then
         -- first case is a hex string, where first char is '#'
         if string.find(red, "^#") then
            local pure_hex = string.sub(red, 2) -- strip format char
            next_num = string.gmatch(pure_hex, "%w%w")
            base = 16

            -- second case is a hex string, where first chars are '|c' or '0x'
         elseif string.find(red, "^[|0][cx]") then
            local pure_hex = string.sub(red, 3) -- strip format chars
            next_num = string.gmatch(pure_hex, "%w%w")
            base = 16
            
            -- third case is a decimal string, of the format "&lt;dd,dd,dd&gt;"
         elseif string.find(red, "^&lt;") then
            next_num = string.gmatch(red, "%d+")

            -- fourth case is a named string
         elseif color_table[red] then
            local i = 0
            local n = #color_table[red]
            next_num = function () -- create a simple iterator
                          i = i + 1
                          if i &lt;= n then return color_table[red][i]
                          else return nil end
                       end
            
         else
            -- finally, no matches, do nothing
            return
         end
      end

   else
      -- Otherwise we weren't passed a complete string, but instead discrete
      -- components as either decimal or hex
      -- Yes, this is a little silly to do this way, but it fits with the
      -- rest of the parsing going on...
      local i = 0
      next_num = function ()
                    i = i + 1
                    if i == 1 then return red
                    elseif i == 2 then return green
                    elseif i == 3 then return blue
                    elseif i == 4 then return alpha
                    else return nil
                    end
                 end
   end
   assign_colors()
   return r,g,b,a
end

--- Applies colors to a window drawing from defaults and overridden values.
-- @param cons The window to apply colors to
function Geyser.Color.applyColors(cons)
   cons:setFgColor(cons.fgColor)
   cons:setBgColor(cons.bgColor)
   cons:setColor(cons.color)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserSetConstraints</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--- This function sets the constraints of a window.
-- It doesn't mess with anything other than positioning data.  It
-- creates get_x(), get_y(), get_width(), and get_height() functions
-- for 'window'
-- @param window The window to create the constraints for.
-- @param cons A table that holds the constraints.
-- @param container A table that holds maximum position values and
-- represents the dimensions of the "window" that holds whatever
-- widget is being created.
function Geyser.set_constraints (window, cons, container)
   -- If container is nil then by default it is the dimensions of the main window
   container = container or Geyser

   -- GENERATE CONSTRAINT AWARE POSITIONING FUNCTIONS
   -- Parse the position constraints to generate functions that will get
   -- window dimensions according to those constraints. Also, update position
   -- information.  The order that the dimensions are specified in the for
   -- loop is important so that get_x() and get_y() are defined before they
   -- needed by width and height.
   for _,v in ipairs{"x", "y", "width", "height"} do
      local getter = "get_" .. v -- name of the function to calculate the

      -- if passed a number assume pixels are meant
      if type(cons[v]) == "number" then
         cons[v] = string.format("%dpx", cons[v])
      end
      
      -- Parse the constraint
      if string.find(cons[v], "%%") then
         -- This handles dimensions as a percentage of the container.
         -- Negative percentages are converted to the equivalent positive.
         --------------------------------------------------------------   

         -- scale is a value between 0 and 1   
         local scale = tonumber((string.gsub(cons[v], "%%", ""))) / 100.0
         if scale &lt; 0 then
            scale = 1 + scale
         end
         local dim = ""
         local min, max = 0,0

         if v == "x" then
            min = "container.get_x()"
            max = "container.get_width()"
         elseif v == "width" then
            max = "container.get_width()"
         elseif v == "y" then
            min = "container.get_y()"
            max = "container.get_height()"
         else
            max = "container.get_height()"
         end
         
         -- Define the getter function
         local src = "local self,container = ...  return function () return " .. min .. " + (" .. scale .. " * " .. max .. ") end"
         
         -- compile the getter
         window[getter] = assert(loadstring(src, "getter for " .. v))(window,container)
         
      else
         -- This handles absolute positioning and character positioning
         -- Negative values indicated positioning from the anti-origin.
         -- Pre: cons[v] must contain "px" or "c"
         --------------------------------------------------------------
         
         -- Create default values
         local x_mult, y_mult = 1,1 -- by default assume not "c"
         local negative = string.find(cons[v], "-") or false -- detect "negative" 0
         
         -- As is, font size is considered a constraint
         if string.find(cons[v], "c") then
            x_mult, y_mult = calcFontSize(window.fontSize)
         end
         
         local pos = tonumber((string.gsub(cons[v], "%a", "")))
         local max = 0
         local min = 0

         if v == "x" then
            min = "container.get_x()"
            pos = x_mult * pos
         elseif v == "width" then
            pos = x_mult * pos
         elseif v == "y" then
            min = "container.get_y()"
            pos = y_mult * pos
         else
            pos = y_mult * pos
         end

         -- Treat negative values differently
         if negative then
            if v == "x" then
               min = "container.get_x()"
               max = "container.get_width()"
            elseif v == "width" then
               min = "container.get_x()"
               max = "container.get_width()"
               pos = string.format("(%d - self:get_x())", pos)
            elseif v == "y" then 
               min = "container.get_y()"
               max = "container.get_height()"
            else -- v == "height"
               min = "container.get_y()"
               max = "container.get_height()"
               pos = string.format("(%d - self:get_y())", pos)
            end
         end

         -- Define the getter function
         local src = "local self, container = ... return function () return " .. max .. " + " .. min .. " + " .. pos .. " end"

         -- compile the getter
         window[getter] = assert(loadstring(src, "getter for " .. v))(window, container)
      end
      
      -- Here the actual value of the dimension is set according to the
      -- constraints requested.
      --window[v] = window[getter]()
   end -- END for that generates POSITION FUNCTIONS

   window:reposition()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserContainer</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--- Represents a generic container with positional information.
-- Has no notion of contents and is used to contain other windows
-- and impose some sense of order.
-- @class table
-- @name Geyser.Container
-- @field parent The parent class of this window
-- @field type The type of this window, usually lowercase of the classname and
--             can be used in checks for certain types. For a Container
--             instance, type is “container.”
-- @field name The name of this window. This is the same name that Mudlet will
--             use internally for primitive types like labels and
--             miniconsoles.  If not specified in the constraints table during
--             creation, an anonymous name unique to this session will be
--             made up.
-- @field x The x-coordinate relative to this window's container, not absolute
--          from the Mudlet main window. This is not a number, but a
--          constraint specification. To find out the numeric x-coordinate in
--          terms of pixels from the Mudlet main window's origin, use the
--          get_x() method. Default is "10px".
-- @field y The y-coordinate relative to this window's container, not absolute
--          from the Mudlet main window. This is not a number, but a
--          constraint specification. To find out the numeric y-coordinate in
--          terms of pixels from the Mudlet main window's origin, use the
--          get_y() method. Default is "10px".
-- @field width The width of this window, possibly relative to the window's
--              container. This is not a number, but a constraint
--              specification. To find out the numeric width in terms of
--              pixels, use the get_width() method. Default is "300px".
-- @field height The height of this window, possibly relative to the window's
--               container. This is not a number, but a constraint
--               specification. To find out the numeric width in terms of
--               pixels, use the get_width() method. Default is "200px".
-- @field windowList This is a list of all windows held by this container. It
--                   used to handle proper resizing of held windows as well as
--                   during show()s and hide()s to recursive show and hide all
--                   children windows.
-- @field fontSize The default size font used when calculating dimensions
--                 based on the character constraint. Default is 8.
Geyser.Container =  {
   name = "ContainerClass",
   x = "10px",
   y = "10px",
   height = "200px",
   width = "300px",
   windowList = {},
   fontSize = 8,
}

--- Responsible for placing/moving/resizing this window to the correct place/size.
-- Called on window resize events.
function Geyser.Container:reposition ()
   local x,y,w,h = self:get_x(), self:get_y(), self:get_width(), self:get_height()
   moveWindow(self.name, self:get_x(), self:get_y())
   resizeWindow(self.name, self:get_width(), self:get_height())
   
   -- deal with all children of this container
   for k,v in pairs(self.windowList) do
      if k ~= self then
         v:reposition()
      end
   end

   -- Calls optional redraw method if it is available to cause a gui element to
   -- redraw itself after moving.
   if self.redraw then self:redraw() end
end

--- Hides this window and all its contained windows.
function Geyser.Container:hide ()
   hideWindow(self.name)
   for _,v in pairs(self.windowList) do
      v:hide()
   end
end

--- Shows this window and all windows it contains.
function Geyser.Container:show ()
   showWindow(self.name)
   for _,v in pairs(self.windowList) do
      v:show()
   end
end

--- Moves this window according to the new x and y contraints set. 
-- @param x New x constraint to use. If nil, uses current value.
-- @param y New y constraint to use. If nil, uses current value.
function Geyser.Container:move (x, y)
   self.x = x or self.x
   self.y = y or self.y
   self:set_constraints(self)
end

--- Resizes this window according to the new width and height constraints set. 
-- @param width New width constraint to use.  If nil, uses current value.
-- @param height New height constraint to use.  If nil, uses current value.
function Geyser.Container:resize (width, height)
   self.width = width or self.width
   self.height = height or self.height
   self:set_constraints(self)
end

--- Sets the default font size for this window.
-- Will resizes this window if necessary to meet constraints.
-- @param fontSize The new font size to use.
function Geyser.Container:setFontSize (fontSize)
   if type(fontSize) ~= "number" then
      error("fontSize must be a number")
      return
   end
   self.fontSize = fontSize or self.fontSize
   self:set_constraints()
end

--- Sets all contraints (x, y, width, height) for this window.
-- @param cons Any Lua table that contains appropriate constraint entries.
function Geyser.Container:set_constraints (cons)
   cons = cons or self
   Geyser.set_constraints(self, cons, self.container)
   for k,v in pairs(self.windowList) do
      v:set_constraints(v)
   end
end

--- Flashes a white box over the dimensions of this container. 
-- This is very useful to see where a container actually is if you've 
-- forgotten its details. 
-- @param time Time in seconds to flash for, default is 1.0s.
function Geyser.Container:flash (time)
   local time = time or 1.0
   local x, y, width, height = self.get_x(), self.get_y(), self.get_width(), self.get_height()
   local name = self.name .. "_dimensions_flash"
   createLabel(name, x, y, width, height, 1)
   resizeWindow(name, width, height)
   moveWindow(name, x, y)
   setBackgroundColor(name, 190, 190, 190, 128)
   showWindow(name)
   tempTimer(time, "hideWindow(\"" .. name .. "\")")
end

Geyser.Container.parent = Geyser.Container -- I'm my own grandpa too!

-- Someone has to be the root!
setmetatable(Geyser.Container, Geyser)

--- Constructor for containers.
-- This function creates a new container/window
-- @param cons Any Lua table that contains appropriate constraint entries.
--             Include any parameter such as name or fontSize in cons
--             that are to be used for the new window.
function Geyser.Container:new(cons, container)
   -- create new table for the container and copy over constraints
   local me = Geyser.copyTable(cons)

   -- enforce a default type, name and parent
   me.type = me.type or "container"
   me.name = me.name or Geyser.nameGen()
   me.windowList = {}

   -- Set the metatable.
   setmetatable(me, self)
   self.__index = self

   -- If we're not not a class definition then add to a controlling
   -- container.
   if not string.find(me.name, ".*Class") then
      -- If passed in a container, add me to that container
      if container then
         container:add(me)
      else
         -- Else assume the root window is my container
         Geyser:add(me)
      end
   end

   --print("New in " .. self.name .. " : " .. me.name)
   return me
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserWindow</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

local cparse = Geyser.Color.parse

--- Represents an abstract window class designed to be subclassed for windows
-- that are built on Mudlet primitives, like labels.
-- @class table
-- @name Geyser.Window
-- @field message The message last *echo()'d to this window. Default is “”.
-- @field bgColor Text background color, default "white"
-- @field fgColor Text foreground color, default "black"
-- @field color Window background color, default "#202020"
Geyser.Window = Geyser.Container:new({
      name = "WindowClass",
      message = "",

      -- default colors.  The are boring
      fgColor = "white",
      bgColor = "black",
      color = "#202020",
   })

-- Add regular window methods, these are mostly just OO-ized wrappers

--- Prints a message to the window
-- @param message The message to print. Can contain html formatting.
function Geyser.Window:echo(message)
   self.message = message
   echo(self.name, self.message)
end

--- Prints a message to the window.
-- @param message The message to print. Uses color formatting information -
-- a message of "&lt;red&gt;Hi" would make 'Hi' red.
function Geyser.Window:cecho(message) self.message = message or self.message cecho(self.name, self.message) end

--- Prints a message to the window.
-- @param message The message to print. Uses color formatting information -
-- a message of "&lt;255,0,0&gt;Hi" would make 'Hi' red.
function Geyser.Window:decho(message) self.message = message or self.message decho(self.name, self.message) end

--- Prints a message to the window.
-- @param message The message to print. Uses color formatting information -
-- a message of "|cff0000Hi" would make 'Hi' red.
function Geyser.Window:hecho(message) self.message = message or self.message hecho(self.name, self.message) end

--- Get the window's foreground color.
-- @return The foreground color of this window primitive as a Geyser.Color object.
function Geyser.Window:getFgColor ()
   return getFgColor(self.name)
end

---  Get the window's background color
-- @return The background color of this window primitive as a Geyser.Color object.
function Geyser.Window:getBgColor ()
   return getBgColor(self.name)
end

--- Sets the background color of this window primitive.  If this primitive
-- was using a shared color, then it creates a new, personal color.
-- @param r The red value, or a quoted color name, like "green".
-- @param g The green value, or nil if using a name.
-- @param b The blue value, or nil if using a name.
function Geyser.Window:setBgColor (r,g,b)
   setBgColor(self.name, cparse(r,g,b))
end

--- Sets the foreground color of this window primitive.  If this primitive
-- was using a shared color, then it creates a new, personal color.
-- @param r The red value, or a quoted color name, like "green".
-- @param g The green value, or nil if using a name.
-- @param b The blue value, or nil if using a name.
function Geyser.Window:setFgColor (r,g,b)
   setFgColor(self.name, cparse(r,g,b))
end

--- Sets the background color and alpha.  If this primitive
-- was using a shared color, then it creates a new, personal color.
-- @param r The red component of the color, or a named color like "green".
-- @param g The green component, or nil if using named colors.
-- @param b The blue component, or nil if using named colors.
-- @param a The alpha component. If nil, uses current alpha value.
function Geyser.Window:setColor (r,g,b,a)
   setBackgroundColor(self.name, cparse(r,g,b,a))
end

--- Pastes text from the clipboard into this window primitive.
function Geyser.Window:paste ()
   paste(self.name)
end

--- Sets the text format for this window. Note that the *echo()
-- functions will override these settings.
-- @param r1 The red foreground component.
-- @param g1 The green foreground component.
-- @param b1 The blue foreground component.
-- @param r2 The red background component.
-- @param g2 The green background component.
-- @param b2 The blue background component.
-- @param bold The bolded status. 1 is bold, 0 is normal.
-- @param underline The underlined status. 1 is underlined, 0 is normal.
-- @param italics The italicized status. 1 is italicized, 0 is normal.
function Geyser.Window:setTextFormat(r1, g1, b1, r1, g2, b2, bold, underline, italics)
   setTextFormat(self.name, r1, g1, b1, r1, g2, b2, bold, underline, italics)
end

--- Sets bolded text.
-- @param bool True for bold.
function Geyser.Window:setBold(bool)
   setBold(self.name, bool)
end

--- Sets underlined text.
-- @param bool True for underlined.
function Geyser.Window:setUnderline(bool)
   setUnderline(self.name, bool)
end

--- Sets italicized text.
-- @param bool True for italicized.
function Geyser.Window:setItalics(bool)
   setItalics(self.name, bool)
end

-- Save a reference to our parent's constructor
Geyser.Window.parent = Geyser.Container

function Geyser.Window:new (cons, container)
   -- Initiate and set Window specific things
   cons = cons or {}
   cons.type = cons.type or "window"

   -- Call parent's constructor
   local me = self.parent:new(cons, container)

   -- Set the metatable.
   setmetatable(me, self)
   self.__index = self

   --print(" New in " .. self.name .. " : " .. me.name)
   return me
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserLabel</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--- Represents a label like we all know and love.
-- @class table
-- @name Geyser.Label
-- @field fillBg 1 if the background is to be filled, 0 for no background.
Geyser.Label = Geyser.Window:new({
      name = "LabelClass",
      format = "",
      args = "",
      fillBg = 1, })

--- Prints a message to the window.  All parameters are optional and if not
-- specified will use the last set value.
-- @param message The message to print. Can contain html formatting.
-- @param color The color to use.
-- @param format A format list to use. 'c' - center, 'b' - bold, 'i' - italics,
--               'u' - underline, '##' - font size.  For example, "cb18" 
--               specifies center bold 18pt font be used.  Order doesn't matter.
function Geyser.Label:echo(message, color, format)
   message = message or self.message
   self.message = self.message
   format = format or self.format
   self.format = format
   color = color or self.fgColor
   self.fgColor = color
   
   local fs = ""
   -- check for formatting commands
   if format then
      if string.find(format, "b") then message = "&lt;b&gt;" .. message .. "&lt;/b&gt;" end
      if string.find(format, "i") then message = "&lt;i&gt;" .. message .. "&lt;/i&gt;" end
      if string.find(format, "c") then message = "&lt;center&gt;" .. message .. "&lt;/i&gt;" end
      if string.find(format, "u") then message = "&lt;u&gt;" .. message .. "&lt;/u&gt;" end
      fs = string.gmatch(format, "%d+")()
      if not fs then fs = tostring(self.fontSize) end
      fs = "font-size: " .. fs .. "pt; "
   end
   message = [[&lt;div style="color: ]] .. Geyser.Color.hex(self.fgColor) .. "; " .. fs ..
             [["&gt;]] .. message .. [[&lt;/div&gt;]]
   echo(self.name, message)
end

function Geyser.Label:setFgColor(color)
   self:echo(nil,color,nil)
end

function Geyser.Label:setFormat(format)
   self:echo(nil,nil,format)
end

--- Sets a background image for this label.
-- @param imageFileName The image to use for a background image.
function Geyser.Label:setBackgroundImage (imageFileName)
   setBackgroundImage(self.name, imageFileName)
end

--- Sets a callback to be used when this label is clicked.
-- @param func The function to use.
-- @param ... Parameters to pass to the function. Must be strings or numbers.
function Geyser.Label:setClickCallback (func, ...)
   setLabelClickCallback(self.name, func, ...)
end

-- Save a reference to our parent constructor
Geyser.Label.parent = Geyser.Window

-- Overridden constructor
function Geyser.Label:new (cons, container)
   -- Initiate and set label specific things
   cons = cons or {}
   cons.type = cons.type or "label"

   -- Call parent's constructor
   local me = self.parent:new(cons, container)

   -- Set the metatable.
   setmetatable(me, self)
   self.__index = self

   -- Create the label using primitives
   createLabel(me.name, me:get_x(), me:get_y(),
               me:get_width(), me:get_height(), me.fillBg)

   -- Set any defined colors
   Geyser.Color.applyColors(me)
   me:echo()

   -- Set up the callback if we have one
   if me.callback then
      me:setClickCallback(me.callback, me.args)
   end

   --print("  New in " .. self.name .. " : " .. me.name)
   return me
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserGauge</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--- Represents a gauge that can be either vertical or horizontal.
-- @class table
-- @name Geyser.Gauge
-- @field value Percentage value of how "full" the gauge is.
-- @field orientation "horizontal" is the default and creates a horizontal
--                    gauge that fills from left to right. "vertical" creates
--                    a gauge that fills from bottom to top. "goofy" is
--                    horizontal but fills right to left. "batty" is
--                    vertical but fills from top to bottom.
-- @field color Color base for this gauge.  Default is #808080
Geyser.Gauge = Geyser.Container:new({
      name = "GaugeClass",
      value = 100, -- ranges from 0 to 100
      color = "#808080",
      orientation = "horizontal"})

--- Sets the gauge amount.
-- @param currentValue Current numeric value, or if maxValue is ommitted, then
--        it is assumed that currentValue is a value between 0 and 100 and is
--        used to set the gauge.
-- @param maxValue Maximum numeric value.  Optionally nil, see above.
-- @param text The text to display on the gauge, it is optional.
function Geyser.Gauge:setValue (currentValue, maxValue, text)
   -- Use sensible defaults for missing parameters.
   if currentValue &lt; 0 then
      currentValue = 0
   end
   if maxValue then
      self.value = currentValue/maxValue * 100
   else
      self.value = currentValue
   end

   -- Update gauge in the requested orientation
   local shift = tostring(self.value) .. "%"
   if self.orientation == "horizontal" then
      self.front:resize(shift, "100%")
   elseif self.orientation == "vertical" then
      self.front:move("0px", "-" .. shift)
      self.front:resize("100%", "-0px") -- bind to bottom container border
   elseif self.orientation == "goofy" then
      self.front:move("-" .. shift, "0px")
      self.front:resize("-0px", "100%") -- bind to right container border
   else -- batty
      self.front:resize("100%", shift)
   end
   
   if text then
      self.front:echo(text)
      self.back:echo(text)
   end
end

--- Sets the gauge color.
-- @param r The red component, or a named color like "green".
-- @param g the green component, or nil if using a named color.
-- @param b the blue component, or nil if using a named color.
-- @param text The text to display on the gauge, it is optional.
function Geyser.Gauge:setColor (r, g, b, text)
   r,g,b = Geyser.Color.parse(r,g,b)
   self.front:setColor(r,g,b)
   self.back:setColor(r,g,b,100)
   if text then
      self.front:echo(text)
      self.back:echo(text)
   end
end

--- Sets the text on the gauge.
-- @param text The text to set.
function Geyser.Gauge:setText (text)
   if text then
      self.front:echo(text)
      self.back:echo(text)
   end
end


-- Save a reference to our parent constructor
Geyser.Gauge.parent = Geyser.Container

-- Overridden constructor
function Geyser.Gauge:new (cons, container)
   -- Initiate and set gauge specific things
   cons = cons or {}
   cons.type = cons.type or "gauge"

   -- Call parent's constructor
   local me = self.parent:new(cons, container)

   -- Set the metatable.
   setmetatable(me, self)
   self.__index = self

   -----------------------------------------------------------
   -- Now create the Gauge using primitives and tastey classes

   -- Set up the constraints for the front label, the label that changes size to
   -- indicated levels in the gauges.
   local front = Geyser.copyTable(cons)
   front.name = me.name .. "_front"
   front.color = me.color
   front.x, front.y, front.width, front.height = 0,0,"100%","100%"

   -- Set up the constraints for the back label, which is always the size of the gauge.
   local back = Geyser.copyTable(front)
   back.name = me.name .. "_back"
   local br, bg, bb = Geyser.Color.parse(me.color)
   back.color = Geyser.Color.hexa(br,bg,bb,100)

   -- Create back first so that the labels are stacked correctly.
   me.back = Geyser.Label:new(back, me)
   me.front = Geyser.Label:new(front, me)
   
   --print("  New in " .. self.name .. " : " .. me.name)
   return me
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserMiniConsole</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--- Represents a miniconsole primitive
-- @class table
-- @name Geyser.MiniConsole
-- @field wrapAt Where line wrapping occurs. Default is 300 characters.
Geyser.MiniConsole = Geyser.Window:new({
      name = "MiniConsoleClass",
      wrapAt = 300,})

--- Replaces the currently selected text.
-- @param with The text to use as a replacement.
function Geyser.MiniConsole:replace (with)
   replace(self.name, with)
end

--- Sets the size of this miniconsole's buffer.
-- @param linesLimit The number of lines to store - same limitations as Mudlet
--                   function of the same name.
-- @param sizeOfBatchDeletion See Mudlet documentation. (I don't know offhand =)
function Geyser.MiniConsole:setBufferSize (linesLimit, sizeOfBatchDeletion)
   setConsoleBufferSize(self.name, linesLimit, sizeOfBatchDeletion)
end

--- Sets the point at which text is wrapped in this miniconsole
-- @param wrapAt The number of characters to start wrapping.
function Geyser.MiniConsole:setWrap (wrapAt)
   if wrapAt then
      self.wrapAt = wrapAt
   end
   setWindowWrap(self.name, self.wrapAt)
end            

--- Sets the text format for this window. Note that the *echo()
-- functions will override these settings.
-- @param r1 The red foreground component.
-- @param g1 The green foreground component.
-- @param b1 The blue foreground component.
-- @param r2 The red background component.
-- @param g2 The green background component.
-- @param b2 The blue background component.
-- @param bold The bolded status. 1 is bold, 0 is normal.
-- @param underline The underlined status. 1 is underlined, 0 is normal.
-- @param italics The italicized status. 1 is italicized, 0 is normal.
function Geyser.MiniConsole:setTextFormat(r1, g1, b1, r2, g2, b2, bold, underline, italics)
   self.fgColor:set(r1,g1,b1)
   self.bgColor:set(r2,b2,g2)
   setTextFormat(self.name, r1, g1, b1, r2, g2, b2, bold, underline, italics)
end

--- Sets bold status for this miniconsole
-- @param bool True for bolded
function Geyser.MiniConsole:setBold(bool)
   setBold(self.name, val)
end
                       
--- Sets underline status for this miniconsole
-- @param bool True for underlined
function Geyser.MiniConsole:setUnderline(bool)
   setUnderline(self.name, val)
end

--- Sets italics status for this miniconsole
-- @param bool True for italicized
function Geyser.MiniConsole:setItalics(bool)
   setItalics(self.name, val)
end

--- Sets the font size for this miniconsole.
-- @param size The font size.
function Geyser.MiniConsole:setFontSize(size)
   self.parent:setFontSize(size)
   setMiniConsoleFontSize(self.name, size)
end

-- Save a reference to our parent constructor
Geyser.MiniConsole.parent = Geyser.Window

-- Overridden constructor
function Geyser.MiniConsole:new (cons, container)
   -- Initiate and set gauge specific things
   cons = cons or {}
   cons.type = cons.type or "miniConsole"

   -- Call parent's constructor
   local me = self.parent:new(cons, container)

   -- Set the metatable.
   setmetatable(me, self)
   self.__index = self

   -----------------------------------------------------------
   -- Now create the MiniConsole using primitives
   createMiniConsole(me.name, me:get_x(), me:get_y(),
                     me:get_width(), me:get_height())

   -- Set any defined colors
   Geyser.Color.applyColors(me)

   if cons.wrapAt then
      me:setWrap(cons.wrapAt)
   end
   
   --print("  New in " .. self.name .. " : " .. me.name)
   return me
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserReposition</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

--- Responds to sysWindowResizeEvent and causes all windows managed
-- by Geyser to update their sizes and positions.
function GeyserReposition()
	for _,window in pairs(Geyser.windowList) do
		window:reposition()
	end
end</script>
					<eventHandlerList>
						<string>sysWindowResizeEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GeyserTests</name>
					<packageName></packageName>
					<script>--------------------------------------
--                                  --
-- The Geyser Layout Manager by guy --
--                                  --
--------------------------------------

-- TESTS FOR GEYSER --

--- Test labels.  Creates 101 Labels of varying hue and transparency.
function Geyser.testLabels()
   labelTestContainer = Geyser.Container:new({x=0,y=0,width="100%",height="100%",name="labelTestContainer"})

   for i=0,90,10 do
      for j=0,90,10 do
         local myName = "TestLabel_" .. i .. "_" .. j
         local l = Geyser.Label:new({
                               name = myName,
                               x = i .. "%", y = j .. "%",
                               width = "8%", height = "8%",
                               message = myName,
                               fgColor = "white"},
                               labelTestContainer)
         l:setColor(i,j,100, i*j/8100 * 128 + 127)
      end
   end
   Geyser.Label:new({
               name = "Clickable",
               fontSize = 22,
               message = [[&lt;p style="font-size:22pt"&gt;&lt;center&gt;Click me&lt;/center&gt;&lt;/p&gt;]],
               x = "53%", y = "53%",
               width = "-40px", height = "-3c",
               backgroundAlpha = 240,
               callback = "echo",
               args = "You Clicked Me!!\n"},
               labelTestContainer)
end



--- Test gauges.  Creates 100 gauges of varying fullness.
function Geyser.testGauges()
   gaugeTestContainer = Geyser.Container:new({x=0,y=0,width="100%",height="100%",name="gaugeTestContainer"})

   for i=0,90,10 do
   for j=0,90,10 do
      local myName = "TestGauge_" .. i .. "_" .. j
      local g = Geyser.Gauge:new({name = myName, x = i .. "%", y = j .. "%", width = "9%", height = "9%",
                                  message = myName, fgColor = "red",},
                                 gaugeTestContainer)
      g:setValue(1.0 * i)
      --g:setText(myName)
   end
   end
end

--- Used by Geyser.demo1(). Sorry about the namespace polution,
-- but callbacks can't use functions contained in a table.  Anyway,
-- it just echoes some status info to the two miniconsoles.
function demoCallback1 (value)
	local g1 = geyserDemoContainer.windowList.myGauge
	local g2 = geyserDemoContainer.windowList.myGoofyGauge
	local c1 = geyserDemoContainer.windowList["console 1"]
	local c2 = geyserDemoContainer.windowList["console 2"]
	g1:setValue((g1.value - value) % 100)
	g2:setValue((g2.value - 2*value) % 100)
	local v1 = tostring(g1.value)
	local v2 = tostring(g2.value)
	c1:decho(string.format("&lt;90,90,%d&gt; You are at %d \n", v1, v1))
	c2:decho(string.format("&lt;90,%d,%d&gt; You are at %d \n", 255-v2, v2, v2))
end

local myDemoState = 0

--- Used by Geyser.demo1(). It moves the location of the
-- container window.  Look how easy it is to shift around all those
-- gui elements!
function demoCallback2 ()
   if myDemoState == 0 then
		geyserDemoContainer:resize(nil, "50%")
		geyserDemoContainer:move("-90c")
		myDemoState = 1
	else
		geyserDemoContainer:resize(nil, "100%")
		geyserDemoContainer:move("-42c")
		myDemoState = 0
	end
end		


--- This demonstrates some of the neat features in Geyser.
function Geyser.demo1()
   ----------------------------------------
   -- 1. Create a container on the left side of the screen wide
   -- enough for 40 characters

   geyserDemoContainer = Geyser.Container:new(
      { x = "-42c", y = "0px",
        width = "40c", height = "100%",
        name = "myContainer"})


   ----------------------------------------
   -- 2. Add a miniconsole to the top of the container,
   -- full width, with 20 lines of text

   local console1 = Geyser.MiniConsole:new(
      { x = "0px", y = "0px",
        width = "100%", height = "20c",
        name = "console 1"},
      geyserDemoContainer) -- add console1 to container directly

   console1:setColor(80,40,20,255)
   console1:echo("Go ahead - resize the Mudlet window\n")


   ----------------------------------------
   -- 3. Add two gauges and a clickable label just below the
   -- miniconsole

   local g1 = Geyser.Gauge:new(
      { x = "0px", y = console1.height,
        width = "60%", height = "4c",
        orientation = "batty", color = "violet",
        name = "myGauge"})
   g1:setValue(77)

   geyserDemoContainer:add(g1) -- add gauge after creation

   local g2 = Geyser.Gauge:new(
      { x = "10%", y = console1.height,
        width = "50%", height = "4c",
        orientation = "goofy",
        name = "myGoofyGauge"}, geyserDemoContainer) -- add gauge directly
   g2:setValue(55)
   g2:setColor("cyan")


   local label1 = Geyser.Label:new(
      { x = g1.width, y = console1.height,
        width = "40%", height = "4c",
        name = "label with callback",
        callback = "demoCallback1",
        args=5, fontSize = 8, fgColor = "white",
        message = "Click me"})

   geyserDemoContainer:add(label1) -- you know the drill

   ----------------------------------------
   -- 4. Add another miniconsole below the gauge that extends
   -- to the bottom of the screen and wraps at 40 characters and
   -- another clickable label.
echo("adfa\n")
   local console2 = Geyser.MiniConsole:new({
        x = "0px", y = "24c",
        width = "100%", height = "-0px",
        name = "console 2",
        wrapAt = 40,
        color = "&lt;10,20,40&gt;",},
        geyserDemoContainer) -- add console2 to geyserDemoContainer directly

   console2:echo("Vampire Gauges!\n")

   local label2 = Geyser.Label:new(
      { x = g1.width, y = "60%",
        width = "40%", height = "4c",
        name = "label with another callback and a long name!",
        callback = "demoCallback2",
        message = [[&lt;center&gt;and me&lt;/center&gt;]]})

   geyserDemoContainer:add(label2) -- same here


   ----------------------------------------
   -- 5. hide all windows just created

   geyserDemoContainer:hide()


   ----------------------------------------
   -- 6. now show them again

   geyserDemoContainer:show()
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>MAG</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Utils - generic - will be in next mudlet release</name>
					<packageName></packageName>
					<script>
--- Generate case insensitive search pattern from string.
---
--- @usage Following example will generate and print "123[aA][bB][cC]" string.
---   &lt;pre&gt;
---   echo(string.genNocasePattern("123abc"))
---   &lt;/pre&gt;
function string.genNocasePattern(s)
	s = string.gsub(s, "%a", 
		function (c)
			return string.format("[%s%s]", string.lower(c), string.upper(c))
		end)
	return s
end


--- Return first matching substring or nil.
--- 
--- @usage Following example will print: "I did find: Troll" string.
---   &lt;pre&gt;
---   local match = string.findPattern("Troll is here!", "Troll")
---   if match then
---      echo("I did find: " .. match)
---   end
---   &lt;/pre&gt;
function string.findPattern(text, pattern)
	if string.find(text, pattern, 1) then
		return string.sub(text, string.find(text, pattern, 1))
	else
		return nil
	end
end


function string.cut(s, maxLen)
	if string.len(s) &gt; maxLen then
		return string.sub(s, 1, maxLen)
	else
		return s
	end
end


function string.trim(s)
	if s then
		return string.gsub(s, "^%s*(.-)%s*$", "%1")
	else
		return s
	end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GAG Utils</name>
					<packageName></packageName>
					<script>
utils = utils or {}


-----------------------------------------------------------------------------
-- gagNext() will create trigger to gag first matching line 
--
-- for example 
--   gagNext("gag this line")
--   gagNext("and this one as well")
--
utils._gag = utils._gag or {}

function utils._gagNextBuildString(key)
	local out = [[deleteLine() killTrigger(utils._gag["]]..key..[["]) utils._gag["]]..key..[["]=nil]]
	return out
end

function utils.gagNext(regexPattern)
	if not utils._gag[regexPattern] then
		local id = tempRegexTrigger(
			regexPattern,
			utils._gagNextBuildString(regexPattern)
		)
		utils._gag[regexPattern] = id
	end
end


-----------------------------------------------------------------------------
-- prompt gaging (in loops and during spellup)
--
function utils.hidePrompt()
	if AConf.Enabled.PromptHiding then
		utils.gagNext("^You will no longer see prompts\.$")
		utils.gagNext("^You will no longer see battle prompts\.$")
		send("prompt;;bprompt", false)
	end
end

function utils.showPrompt()
	if AConf.Enabled.PromptHiding then
		utils.gagNext("^You will now see prompts\.$")
		utils.gagNext("^You will now see battle prompts\.$")
		send("prompt;;bprompt", false)
	end
end


-----------------------------------------------------------------------------
-- empty line gaging
--
utils.gag_empty_lines_id = nil
utils.gag_empty_lines_stop_id = nil

function utils.startGagEmptyLines()
	if AConf.Enabled.PromptHiding then
		if not utils.gag_empty_lines_id then
			utils.gag_empty_lines_id = tempRegexTrigger("^$", [[deleteLine()]])
		end
	end
end

function utils.stopGagEmptyLines()
	if utils.gag_empty_lines_id then
		killTrigger(utils.gag_empty_lines_id)
		utils.gag_empty_lines_id = nil
	end
end

function utils.stopGagEmptyLinesOn(pattern)
	if utils.gag_empty_lines_stop_id then
		killTrigger(utils.gag_empty_lines_stop_id)
	end
	utils.gag_empty_lines_stop_id = tempTrigger(
		pattern, 
		[[utils.stopGagEmptyLines() killTrigger(utils.gag_empty_lines_stop_id) deleteLine()]]
	)
end
</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Aardwolf Configuration</name>
					<packageName></packageName>
					<script>
-- Mudled Aardwolf GUI (MAG)


-- !!! Please modify only "User Configuration" scripts !!!

-- !!! You have to SAVE ITEM, SAVE PROFILE and RESTART Mudlet after all changes in this file !!!
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Defaults (don't modify)</name>
						<packageName></packageName>
						<script>
---------------------------------------------------------------
-- Mudled Aardwolf GUI (MAG) - default values
--

--
-- !!! Don't modify this script !!! Amend User Configuration script instead !!!
--



-- init on session start
if not AConf then

   AConf                            = {}
   AConf.MAG                        = {}
   AConf.MAG.name                   = "Mudled Aardwolf GUI"
   AConf.MAG.version                = "1.1.0"
   AConf.MAG.www                    = "http://www.aardwolf.com/wiki/index.php/Clients/MudletAardwolfGUI"


   AConf.GUI                        = {}
   AConf.GUI.Right_wrap             = 45
   AConf.GUI.Right_fontsize         = 11
   AConf.GUI.Bottom_fontsize        = 10


   AConf.Actions                    = {}
   AConf.Actions.spellUp            = "spellup learned wis;; spellup learned"
   AConf.Actions.usePortalToRecall  = "recall"
   AConf.Actions.runToQuestor       = "rt questor"
   AConf.Actions.recallEatAndSleep  = "recall ;; run u3n ;; drin ;; run 5nen ;; sle bed"


   AConf.Questors = { "Questor", "A QuestoR", "Omar" }


   AConf.Enabled                    = {}
   AConf.Enabled.Right              = true      -- todo not fully implemented/tested
   AConf.Enabled.Bottom             = true
   AConf.Enabled.Statistics         = true
   AConf.Enabled.ReSpellUp          = false
   AConf.Enabled.BarterWatcher      = false
   AConf.Enabled.TickTimer          = true
   AConf.Enabled.PromptHiding       = true


   AConf.Statistics                 = {}
   AConf.Statistics.Timer_enabled   = true
   AConf.Statistics.Timer_time      = (30*60)


   AConf.GUI.StatMon_lines          = 14
   AConf.GUI.StatMon_warning        = 11
   AConf.GUI.StatMon_critical       = 6


end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>User Configuration</name>
						<packageName></packageName>
						<script>
---------------------------------------------------------------
-- Mudled Aardwolf GUI (MAG) - User Configuration
--

--
-- 1) amend configuration line(s)
--       find and modify your configuration
--       you have to uncomment that line as well 
--          - you can comment it out for default value)
--          - lines starting with -- are commented (ignored)
--
-- 2) !!! You have to SAVE ITEM and SAVE PROFILE !!!
--
-- 3) You also have to RESTART Mudlet for most changes!
-- 



--AConf.GUI.Right_wrap             = 85
--AConf.GUI.Right_fontsize         = 12
--AConf.GUI.Bottom_fontsize        = 11


--AConf.Actions.spellUp            = "spellup learned wis;; spellup learned"
--AConf.Actions.usePortalToRecall  = "wear 'garbage can' ;; enter ;; wear 'skipping'"
--AConf.Actions.runToQuestor       = "e ;; e"
--AConf.Actions.recallEatAndSleep  = "recall ;; run u3n5ne ;; drin ;; fill Goblet ;; n ;; sle bed"


--AConf.Questors = { "Questor", "A QuestoR", "Omar" }


--AConf.Enabled.Right              = false
--AConf.Enabled.Bottom             = false
--AConf.Enabled.Statistics         = false
--AConf.Enabled.ReSpellUp          = true
--AConf.Enabled.BarterWatcher      = true
--AConf.Enabled.TickTimer          = false
--AConf.Enabled.PromptHiding       = false


--AConf.Statistics.Timer_enabled   = true
--AConf.Statistics.Timer_time      = (30*60)


--AConf.GUI.StatMon_lines          = 14
--AConf.GUI.StatMon_warning        = 11
--AConf.GUI.StatMon_critical       = 6
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Calculated (don't modify)</name>
						<packageName></packageName>
						<script>
---------------------------------------------------------------
-- Mudled Aardwolf GUI (MAG) - calculated values
--

-- 
-- !!! Don't modify this script !!! Amend User Configuration script instead !!!
--



-- init on session start
if not AConf.GUI.Bottom_trigger_width then

   AConf.Enabled.ChatLog            = true   and AConf.Enabled.Right  
   AConf.Enabled.ExtraInfo          = true   and AConf.Enabled.Right  
   AConf.Enabled.MiniMap            = true   and AConf.Enabled.Bottom 
   AConf.Enabled.StatusArea         = true   and AConf.Enabled.Bottom 
   AConf.GUI.Bottom_rows            = 15

   -- calculate right width
   right_x_mult, right_y_mult       = 1,1
   right_x_mult, right_y_mult       = calcFontSize(AConf.GUI.Right_fontsize)
   AConf.GUI.Right_width            = (right_x_mult*(AConf.GUI.Right_wrap+1))

   -- calculate bottom height
   bottom_x_mult, bottom_y_mult     = 1,1
   bottom_x_mult, bottom_y_mult     = calcFontSize(AConf.GUI.Bottom_fontsize)
   AConf.GUI.Bottom_height          = (bottom_y_mult*(AConf.GUI.Bottom_rows+1))

   -- calculate bottom mini map width
   AConf.GUI.Bottom_mm_spacer       = (bottom_x_mult*4)
   AConf.GUI.Bottom_mm_width        = (bottom_x_mult*33)
   AConf.GUI.Bottom_mm_total_width  = AConf.GUI.Bottom_mm_spacer + AConf.GUI.Bottom_mm_width

   -- calculate bottom stat mon width
   AConf.GUI.Bottom_sm_width        = (bottom_x_mult*15)

   -- calculate trigger button width
   AConf.GUI.Bottom_trigger_width   = (bottom_x_mult*21)

end
</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Mudlet Aardwolf GUI</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>MAG Utils</name>
						<packageName></packageName>
						<script>
-- Mudlet Aardwolf GUI Utils package
MAGU = MAGU or {}	


function MAGU.clear(consoleName)
	clearUserWindow(consoleName)
end


function MAGU.echo(consoleName, message)
	echo(consoleName, (message or "\n"))
end


function MAGU.cecho(consoleName, message)
	cecho(consoleName, (message or "\n"))
end


-- todo get rid of console name
-- captureGroup = nil - current line
function MAGU.selectCaptured(captureGroup)
	selectCaptureGroup(captureGroup or 1)
	copy()
end


function MAGU.copySelected(consoleName, printNewLine)
	appendBuffer(consoleName)
	if printNewLine then 
		MAGU.echo(consoleName) 
	end
end


function MAGU.moveSelected(consoleName, printNewLine)
	MAGU.copySelected(consoleName, printNewLine)
	deleteLine()
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Core</name>
						<packageName></packageName>
						<script>
-- TODO distant future
	-- make it more generic - just add minicilnsole, and pref in table
	-- return window object and manipulate with that... (amend AGU)

-- available consoles - use table for gettign names
  -- MAG.name_cl
  -- MAG.name_ei
  -- MAG.name_mm
  -- MAG.name_sa
  -- MAG.name_sm


-- Aardwolf GUI package
MAG = MAG or {}


function MAG.init()
	-- create top container (will consume all available space)
	MAG.name_top = MAG.name_top or Geyser.nameGen("Container_top")
	MAG.top = Geyser.Container:new(
		{
			name = MAG.name_top,
			x = 0,
			y = 0,
			width = "100%",
			height = "100%"
		} 
	)
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Right Container</name>
						<packageName></packageName>
						<script>
-----------------------------------------
-- Create Right Container
--
function MAG.create_right_container()
	-- create right container
	MAG.name_right = MAG.name_right or Geyser.nameGen("Container_right")
	MAG.right = Geyser.Container:new(
		{
			name = MAG.name_right,
			x = (-1)*AConf.GUI.Right_width,
			y = 0,
			width = AConf.GUI.Right_width,
			height = "100%"
		}, 
		MAG.top
	)
end


-----------------------------------------
-- Create Chat Log (says, tells, channels, ...)
--
function MAG.create_chatLog_console()
	if AConf.Enabled.ChatLog then
		MAG.name_cl = MAG.name_cl or Geyser.nameGen("MiniConsole_ChatLog")
		MAG.chatLog = Geyser.MiniConsole:new(
			{
				name = MAG.name_cl,
				x = 0, 
				y = 0,
				width = "100%",
				height =	(-1)*(AConf.GUI.Bottom_height + 20)
			}, 
			MAG.right
		)
		MAG.chatLog:setColor(0, 0, 0, 0)
		MAG.chatLog:setFontSize(AConf.GUI.Right_fontsize)
		MAG.chatLog:setWrap(AConf.GUI.Right_wrap)
		-- move cursor to the end  (just once, it will not delete chat history)
		if not MAG.cl_cleared then
			MAGU.clear(MAG.name_cl)
			MAG.cl_cleared = true
			-- splash
			MAGU.echo(MAG.name_cl, "\n" .. AConf.MAG.name .. " " .. AConf.MAG.version .. "\n\n")
			MAGU.echo(MAG.name_cl, AConf.MAG.www .. "\n\n\n\n")
		end
	end
end


-----------------------------------------
-- Extra Info (mainly quest oriented)
--
function MAG.create_extraInfo_console()
	if AConf.Enabled.ExtraInfo then
		MAG.name_ei = MAG.name_ei or Geyser.nameGen("MiniConsole_ExtraInfo")
		MAG.extraInfo = Geyser.MiniConsole:new(
			{
				name = MAG.name_ei,
				x = 0, 
				y =	(-1)*AConf.GUI.Bottom_height,
				width = "100%",
				height = AConf.GUI.Bottom_height
			}, 
			MAG.right
		)
		MAG.extraInfo:setColor(0, 0, 0, 0)
		MAG.extraInfo:setFontSize(AConf.GUI.Bottom_fontsize)
		MAG.extraInfo:setWrap(AConf.GUI.Right_wrap)
		MAGU.clear(MAG.name_ei)
		setConsoleBufferSize(MAG.name_ei, 100, 10)
	end
end


-----------------------------------------
-- Right Container Inicialization
--
function MAG.initRightContainer()
	if AConf.Enabled.ChatLog or AConf.Enabled.ExtraInfo then
		setBorderRight(AConf.GUI.Right_width + 10)
		MAG.create_right_container()
		MAG.create_chatLog_console()
		MAG.create_extraInfo_console()
	else
		setBorderRight(0)
	end
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Bottom Container</name>
						<packageName></packageName>
						<script>
-----------------------------------------
-- Create bottom Container
--
function MAG.create_bottom_container()
	-- create bottom container
	MAG.name_bottom = MAG.name_bottom or Geyser.nameGen("Container_bottom")
	MAG.bottom = Geyser.Container:new(
		{
			name = MAG.name_bottom,
			x = 0,
			y = (-1)*AConf.GUI.Bottom_height,
			width = (-1)*AConf.GUI.Right_width,
			height = AConf.GUI.Bottom_height
		}, 
		MAG.top
	)
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Tick Info</name>
						<packageName></packageName>
						<script>
-----------------------------------------
-- Tick Info
--
function MAG.create_tickInfo_console()
	if AConf.Enabled.StatusArea then
		MAG.name_ti = MAG.name_ti or Geyser.nameGen("MiniConsole_TickInfo")
		MAG.tickInfo = Geyser.MiniConsole:new(
			{
				name = MAG.name_ti,
				x = 0,
				y = 0,
				width = AConf.GUI.Bottom_mm_spacer,
				height = "100%"
			}, 
			MAG.bottom
		)
		MAG.tickInfo:setColor(0, 0, 0, 0)
		MAG.tickInfo:setFontSize(AConf.GUI.Bottom_fontsize)
		setConsoleBufferSize(MAG.name_ti, 100, 10)
	end
end


-----------------------------------------
-- supporting functions
--
MAG.tick			= MAG.tick or {}
MAG.tick.max		= 30
MAG.tick.rows	= AConf.GUI.Bottom_rows
MAG.tick.slice	= (MAG.tick.max/MAG.tick.rows)


function MAG.tick.start()
	MAG.tick.progress()
	MAG.tick.startTime = os.time()
	if not MAG.tick.alreadyInitialized then
		MAG.tick.alreadyInitialized = true
		MAG.tick.timer()
	end
end


function MAG.tick.progress()
	if MAG.tick.startTime then
		local time = os.difftime(os.time(), MAG.tick.startTime)
		if time &lt;= MAG.tick.slice then 
			MAGU.clear(MAG.name_ti)
		elseif time &gt;= (MAG.tick.max - 2*MAG.tick.slice) then 
			MAGU.cecho(MAG.name_ti, "&lt;grey&gt;\""  .. "\n")
		else
			MAGU.cecho(MAG.name_ti, "&lt;grey&gt;'"  .. "\n")
		end
	end
end


function MAG.tick.timer()
	if MAG.tick.startTime then
		MAG.tick.progress()
		tempTimer(MAG.tick.slice, [[MAG.tick.timer()]])
	end
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Mini Map</name>
						<packageName></packageName>
						<script>
-----------------------------------------
-- Create Mini Map
--
function MAG.create_miniMap_console()
	if AConf.Enabled.MiniMap then
		MAG.name_mm = MAG.name_mm or Geyser.nameGen("MiniConsole_MiniMap")
		MAG.miniMap = Geyser.MiniConsole:new(
			{
				name = MAG.name_mm,
				x = AConf.GUI.Bottom_mm_spacer,
				y = 0,
				width = AConf.GUI.Bottom_mm_width,
				height = "100%"
			}, 
			MAG.bottom
		)
		MAG.miniMap:setColor(0, 0, 0, 0)
		MAG.miniMap:setFontSize(AConf.GUI.Bottom_fontsize)
		MAGU.clear(MAG.name_mm)
		setConsoleBufferSize(MAG.name_mm, 100, 10)
	end
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Status Area</name>
						<packageName></packageName>
						<script>
-----------------------------------------
-- Stats Mon (HP, MN, MV, Emeny)
--
function MAG.create_statsMon_console()
	if AConf.Enabled.StatusArea then
		MAG.name_sm = MAG.name_sm or Geyser.nameGen("MiniConsole_StatsMonitor")
		MAG.statsMon = Geyser.MiniConsole:new(
			{
				name = MAG.name_sm,
				x = AConf.GUI.Bottom_mm_total_width,
				y = "0%",
				width = AConf.GUI.Bottom_sm_width,
				height = "100%"
			}, 
			MAG.bottom
		)
		MAG.statsMon:setColor(0, 0, 0, 0)
		MAG.statsMon:setFontSize(AConf.GUI.Bottom_fontsize)
		setConsoleBufferSize(MAG.name_sm, 100, 10)
	end
end


function MAG.sm_print(per, index)
	local num = tonumber(per)
	local maxPer = 100*(AConf.GUI.StatMon_lines-index+1)/AConf.GUI.StatMon_lines
	if (num ~= nil) and (num &gt;= maxPer) then
		MAGU.echo(MAG.name_sm, "#  ")
	else
		MAGU.echo(MAG.name_sm, "   ")
	end
end


function MAG.sm_update(h, m, v, e)
	local ee = nil
	if e~="9999" then 
		ee=tonumber(e) 
	end
	MAGU.clear(MAG.name_sm)
	for i=1, AConf.GUI.StatMon_lines do 
		-- set color
		local invIndex = AConf.GUI.StatMon_lines-i+1
		if invIndex == AConf.GUI.StatMon_lines then
			setFgColor(MAG.name_sm, 0, 255, 0)
		elseif invIndex == AConf.GUI.StatMon_warning then
			setFgColor(MAG.name_sm, 255, 255, 0)
		elseif invIndex == AConf.GUI.StatMon_critical then
			setFgColor(MAG.name_sm, 255, 0, 0)
		end
		-- print stats
		MAG.sm_print(h, i)
		MAG.sm_print(m, i)
		MAG.sm_print(v, i)
		MAGU.echo(MAG.name_sm, "  ")
		MAG.sm_print(ee, i)
		MAGU.echo(MAG.name_sm, "\n")
	end
	setFgColor(MAG.name_sm, 255, 255, 255)
	MAGU.echo(MAG.name_sm, "H  M  V")
	if ee~=nil then 
		MAGU.echo(MAG.name_sm, "    E") 
	end
end



-----------------------------------------
-- Create Status Area
--
function MAG.create_statusArea_console()
	if AConf.Enabled.StatusArea then
		MAG.name_sa = MAG.name_sa or Geyser.nameGen("MiniConsole_StatusArea")
		MAG.statusArea = Geyser.MiniConsole:new(
			{
				name = MAG.name_sa,
				x = AConf.GUI.Bottom_mm_total_width + AConf.GUI.Bottom_sm_width,
				y = "0%",
				width =  (-1)*AConf.GUI.Bottom_mm_spacer,
				height = "100%"
			}, 
			MAG.bottom
		)
		MAG.statusArea:setColor(0, 0, 0, 0)
		MAG.statusArea:setFontSize(AConf.GUI.Bottom_fontsize)
		setConsoleBufferSize(MAG.name_sa, 100, 10)
	end
end


function MAG.sa_getQuestTime()
	if MAG.sa_questTime then
		local num = tonumber(MAG.sa_questTime)
		if num == 0 then
			return string.format("&lt;cyan&gt;Quest time   : &lt;red&gt;%7d", tonumber(MAG.sa_questTime))
		else
			return string.format("&lt;cyan&gt;Quest time   : &lt;green&gt;%7d", tonumber(MAG.sa_questTime))
		end
	else
		return ""
	end
end


function MAG.sa_getOtherFlags()
	return MAG.sa_hunger or ""
end


--  1, 2	current str / base str,
--  3, 4	current int / base int,
--  5, 6	current wis / base wis,
--  7, 8	current dex / base dex,
--  9,10	current con / base con,
-- 11,12	current luck / base luck,
-- 13-15	hp percent, mana percent, moves percent,
-- 16,17	hitroll, damroll,
-- 18,19	position, enemy pct (9999 if not fighting),
-- 20-25	hp / maxhp,  mana / max mana,  moves / max moves,
-- 26-28	gold, qp, tp,
-- 29-31	align, exp to level, current leel,
--    32	position (number)
function MAG.updateStatusArea(statusUpdate)
	-- use previous data for refresh
	if statusUpdate == nil then
		statusUpdate = MAG.su_lastUpdate
		if statusUpdate == nil then
			return
		end
	end
	MAG.su_lastUpdate = statusUpdate
	-- split input string
	local su = {}
	for w in string.gmatch(statusUpdate, "[^,/]+") do
		table.insert(su, w)
	end
	-- update stats mon
	MAG.sm_update(su[13], su[14], su[15], su[19])
	-- print something out
	MAGU.clear(MAG.name_sa)
	MAGU.cecho(MAG.name_sa)
	if MAG.sa_roomName then 
		MAGU.cecho(MAG.name_sa, string.format("&lt;green&gt;%s\n", MAG.sa_roomName))
	else
		MAGU.cecho(MAG.name_sa)
	end
	MAGU.cecho(MAG.name_sa)
	if MAG.c102.combat() then
		MAGU.cecho(MAG.name_sa, "&lt;red&gt;" .. su[18] .. "\n")
	else
		MAGU.cecho(MAG.name_sa, su[18] .. "\n")
	end
	MAGU.cecho(MAG.name_sa)
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;Health  : &lt;white&gt;%5d&lt;cyan&gt;/&lt;white&gt;%5d      &lt;cyan&gt;Strength     : &lt;white&gt;%3d&lt;cyan&gt;/&lt;white&gt;%3d\n", su[20], su[21], su[1], su[2]))
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;Mana    : &lt;white&gt;%5d&lt;cyan&gt;/&lt;white&gt;%5d      &lt;cyan&gt;Intelligence : &lt;white&gt;%3d&lt;cyan&gt;/&lt;white&gt;%3d\n", su[22], su[23], su[3], su[4]))
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;Moves   : &lt;white&gt;%5d&lt;cyan&gt;/&lt;white&gt;%5d      &lt;cyan&gt;Wisdom       : &lt;white&gt;%3d&lt;cyan&gt;/&lt;white&gt;%3d\n", su[24], su[25], su[5], su[6]))
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;                           Dexterity    : &lt;white&gt;%3d&lt;cyan&gt;/&lt;white&gt;%3d\n", su[7], su[8]))
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;Hitroll : &lt;white&gt;%11d      &lt;cyan&gt;Constitution : &lt;white&gt;%3d&lt;cyan&gt;/&lt;white&gt;%3d\n", su[16], su[9], su[10]))
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;Damroll : &lt;white&gt;%11d      &lt;cyan&gt;Luck         : &lt;white&gt;%3d&lt;cyan&gt;/&lt;white&gt;%3d\n", su[17], su[11], su[12]))
	MAGU.cecho(MAG.name_sa)
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;TNL     : &lt;white&gt;%11d      &lt;cyan&gt;Level        : &lt;green&gt;%7d\n", su[30], su[31]))
	MAGU.cecho(MAG.name_sa, string.format("&lt;cyan&gt;Align   : &lt;white&gt;%11d      %s\n", su[29], MAG.sa_getQuestTime()))
	MAGU.cecho(MAG.name_sa)
	MAGU.cecho(MAG.name_sa, MAG.sa_getOtherFlags())
	-- todo [spell off flag, blind, noexp, double]
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Toggles</name>
						<packageName></packageName>
						<script>
-----------------------------------------
-- Re-SpellUp Toggle
--
function MAG.sa_spellUpToggle_getMessage()
	local out = "Re-SpellUp "
	if AConf.Enabled.ReSpellUp then
		out = out .. "ON"
	else
		out = out .. "OFF"
	end
	return out
end


-- callback handler cannot be within package e.g. MAG.bla (must be MAG_bla)
function MAG_sa_spellUpToggle_callback()
	if AConf.Enabled.ReSpellUp then
		AConf.Enabled.ReSpellUp = false
	else
		AConf.Enabled.ReSpellUp = true
	end
	MAG.sa_spelup_button:echo(MAG.sa_spellUpToggle_getMessage())
end


function MAG.create_sa_spellUpToggle()
	MAG.name_sa_spelup_button = MAG.name_sa_spelup_button or Geyser.nameGen("name_sa_spelup_button")
	MAG.sa_spelup_button = Geyser.Label:new(
		{
			name = MAG.name_sa_spelup_button,
			fontSize = AConf.GUI.Bottom_fontsize,
			message = MAG.sa_spellUpToggle_getMessage(),
			x = (-1)*AConf.GUI.Bottom_trigger_width,
			y = (-1)*bottom_y_mult,
			width = 20*bottom_x_mult, 
			height = bottom_y_mult,
			fgColor = "grey",
			callback = "MAG_sa_spellUpToggle_callback"
		},
      MAG.bottom
	)
	MAG.sa_spelup_button:setColor(0,0,0,0)
end


-----------------------------------------
-- Barter Watcher Toggle
--
function MAG.sa_barterWatcherToggle_getMessage()
	local out = "Barter Watcher "
	if AConf.Enabled.BarterWatcher then
		out = out .. "ON"
	else
		out = out .. "OFF"
	end
	return out
end


-- callback handler cannot be within package e.g. MAG.bla (must be MAG_bla)
function sa_barterWatcherToggle_callback()
	if AConf.Enabled.BarterWatcher then
		AConf.Enabled.BarterWatcher = false
	else
		AConf.Enabled.BarterWatcher = true
	end
	MAG.sa_barter_button:echo(MAG.sa_barterWatcherToggle_getMessage())
end


function MAG.create_sa_barterWatcherToggle()
	MAG.name_sa_barter_button = MAG.name_sa_barter_button or Geyser.nameGen("name_sa_barter_button")
	MAG.sa_barter_button = Geyser.Label:new(
		{
			name = MAG.name_sa_barter_button,
			fontSize = AConf.GUI.Bottom_fontsize,
			message = MAG.sa_barterWatcherToggle_getMessage(),
			x = (-2)*AConf.GUI.Bottom_trigger_width,
			y = (-1)*bottom_y_mult,
			width = AConf.GUI.Bottom_trigger_width,
			height = bottom_y_mult,
			fgColor = "grey",
			callback = "sa_barterWatcherToggle_callback"
		},
      MAG.bottom
	)
	MAG.sa_barter_button:setColor(0,0,0,0)
end


-- refresh button labels
function MAG.toggleUpdate()
	MAG.sa_spelup_button:echo(MAG.sa_spellUpToggle_getMessage())
	MAG.sa_barter_button:echo(MAG.sa_barterWatcherToggle_getMessage())
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Bottom Initialization</name>
						<packageName></packageName>
						<script>
-----------------------------------------
-- bottom Container Inicialization
--
function MAG.initBottomContainer()
	if AConf.Enabled.StatusArea or AConf.Enabled.MiniMap then
		setBorderBottom(AConf.GUI.Bottom_height)
		MAG.create_bottom_container()
		MAG.create_tickInfo_console()
		MAG.create_miniMap_console()
		MAG.create_statsMon_console()
		MAG.create_statusArea_console()
		MAG.create_sa_spellUpToggle()
		MAG.create_sa_barterWatcherToggle()
	else
		setBorderBottom(0)
	end
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG channel 102</name>
						<packageName></packageName>
						<script>
--------------------------------------------
-- Channel 102
--
MAG.c102 = {}


-- enable all required tags
-- 1 - on,  2 - off
MAG.c102.on = { 
	"\1\1",		-- Statmon
	"\2\2",		-- Bigmap + Coordinates tags
	"\3\2",		-- Help tags
	"\4\1",		-- Map tags
	"\5\1",		-- Channel tags
	"\6\1",		-- Tell tags
	"\7\1",		-- Spellup tags
	"\8\2",		-- Skillgains tags
	"\9\1",		-- Say tags
	"\11\2",	-- Score tags
	"\12\1",	-- Room names in mapper
	"\14\2",	-- Exits in mapper
	"\15\2",	-- Editor tags
	"\16\2",	-- Equip tags
	"\17\2",	-- Inventory tags
	"\18\2",	-- Room desc tags
	"\19\2",	-- Room name tags
	"\50\2",	-- Quiet all tags (tags quiet on/off)
	"\51\1",	-- Turn autotick on/off
	"\52\1",	-- Turn prompts on/off
	"\53\2",	-- Turn output paging on/off (remembers pagesize)
	"\54\1",	-- Turn automap on/off
	"\55\2"		-- Turn shortmap on/off
}


function MAG.c102.send(list)
	for i,item in ipairs(list) do
		sendTelnetChannel102(item)
	end
end



--[[
  100,1 	At login screen, no player yet
  100,2 	Player at MOTD or other login sequence
  100,3 	Player fully active and able to receive MUD commands
  100,4 	Player AFK
  100,5 	Player in note mode
  100,6 	Player in Building/Edit mode
  100,7 	Player at paged output prompt
  100,8 	Player in combat
  100,9 	Player sleeping
  100,11 	Player resting

  101,1   Game Tick.
--]]
function MAG.c102.checkCode(code)
	for k,v in pairs(channel102) do
		if k==100 and v==code then
			return true
		end
	end
	return false
end


function MAG.c102.afk()
	return MAG.c102.checkCode(4)
end


function MAG.c102.combat()
	return MAG.c102.checkCode(8)
end


function MAG.c102.sleepingOrResting()
	return MAG.c102.checkCode(9) or MAG.c102.checkCode(11)
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>MAG Initialization</name>
						<packageName></packageName>
						<script>
------------------------------------
-- INIT
--

-- setup all tags for current char - called from trigger
function MAG.avatarSetup()
	MAG.c102.send(MAG.c102.on)
	cecho("\n&lt;red&gt;---- Setting up MAG tags ----\n")
end


-- setup gui
function MAG.startMAG()
	setBorderLeft(7)
	setBorderBottom(0)
	MAG.init()	
	MAG.initRightContainer()
	MAG.initBottomContainer()
end


MAG.startMAG()



------------------------------------
-- Optional settings
--

-- Setup my favourite prompt 
--   !MAG.avatarSetup_prompt()
function MAG.avatarSetup_prompt()
	send("prompt  [%h/%Hh %m/%Mm %N %qqt %Xtnl] @G%r @w&gt; ")
	send("bprompt [%h/%Hh %m/%Mm %N %Xtnl]@C%b @w&gt; ")
end
</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Statistics</name>
					<packageName></packageName>
					<script>
---------------------------------
-- stats package
--


stats = stats or {}

stats.c1 = "&lt;dark_orchid&gt;"
stats.c2 = "&lt;cyan&gt;"

stats.session = stats.session or {}
stats.area = stats.area or {}


function stats.reset(st_src, name)
	st_src.name = name
	st_src.print = true
	st_src.time = os.time()
	st_src.kills = 0
	st_src.gold = 0
	st_src.exp = 0
	st_src.qp = 0
end


-- increment data
function stats.getNum(value)
	if value then
		-- 123 + 12 + 12
		if (string.find(value, "+")) then
			local out = 0
			for w in string.gmatch(value, "[^+/]+") do
				out = out + stats.getNum_single(w)
			end
			return out
		else
			-- 123,456
			return stats.getNum_single(value)
		end
	else
		return 0
	end
end


function stats.getNum_single(value)
	value = tostring(string.gsub(value, ",", ""))
	return (tonumber(value) or 0)
end



function stats.addKill()
	stats.session.kills = stats.session.kills + 1
	stats.area.kills = stats.area.kills + 1
end


function stats.addExp(value)
	stats.session.exp = stats.session.exp + stats.getNum(value)
	stats.area.exp = stats.area.exp + stats.getNum(value)
end


function stats.addGold(value)
	stats.session.gold = stats.session.gold + stats.getNum(value)
	stats.area.gold = stats.area.gold + stats.getNum(value)	
end


function stats.addQp(value)
	stats.session.qp = stats.session.qp + stats.getNum(value)
	stats.area.qp = stats.area.qp + stats.getNum(value)
end



-- print stats
function stats.per(value, div)
	if div == 0 then div = 1 end
	return math.floor((value*10/div) + 0.5) / 10
end


function stats.niceTime(minutes)
	local out = ""
	if minutes &lt; 1 then
		out = out .. "less than minute:\n"
	elseif minutes &lt; 2 then
		out = out .. "last minute:\n"
	elseif minutes &gt; 59 then
		out = "last  "
		local h = math.floor(minutes/60)
		local m = minutes - h*60
		out = out .. stats.c1 .. h .. stats.c2 .. " hour"
		if h &gt; 1 then 
			out = out .. "s"
		end
		-- minutes
		if m == 1 then
			out = out .. "  " .. stats.c1 .. m .. stats.c2 .. " minute"
		elseif m &gt; 1 then
			out = out .. "  " .. stats.c1 .. m .. stats.c2 .. " minutes"
		end
		out = out .. ":\n"
	else
		out = "last  "
		out = out .. stats.c1 .. minutes .. stats.c2 .. " minutes:\n"
	end
	return out
end


function stats.print(st_src)
	if st_src.print then
		local minutes = os.difftime(os.time(), st_src.time) / 60
		minutes = math.floor(minutes)
		local out = stats.c1 .. "\n" .. st_src.name .. stats.c2 .. " for " .. stats.niceTime(minutes)
		-- build stats report
		out = out .. string.format("   Kills %9d   %7.1f/min", st_src.kills, stats.per(st_src.kills, minutes)) .. "\n"
		out = out .. string.format("   Gold  %9d   %7.1f/min   %7.1f/kill",
			st_src.gold, stats.per(st_src.gold, minutes), stats.per(st_src.gold, st_src.kills)) .. "\n"
		out = out .. string.format("   Exp   %9d   %7.1f/min   %7.1f/kill",
			st_src.exp, stats.per(st_src.exp, minutes), stats.per(st_src.exp, st_src.kills)) .. "\n"
		out = out .. string.format("   QP    %9d   %7.1f/min", st_src.qp, stats.per(st_src.qp, minutes)) .. "\n"
		-- print stats (can be also send to gt for example)
		cecho(out)
	end
end


function stats.printAll()
		stats.print(stats.session)
		stats.print(stats.area)
		echo("\n")
end


-- timer for showing session stats
function stats.timer()
	stats.printAll()
	if AConf.Statistics.Timer_enabled then
		tempTimer(AConf.Statistics.Timer_time, [[stats.timer()]])
	end
end


function stats.showHelp()
	cecho("\nMAG statistics commands:\n")
	cecho("    &lt;cyan&gt;s ?&lt;grey&gt;  or  &lt;cyan&gt;stat help&lt;grey&gt;    show this help\n")
	cecho("    &lt;cyan&gt;s p&lt;grey&gt;  or  &lt;cyan&gt;stat print&lt;grey&gt;   print out statistics\n")
	cecho("    &lt;cyan&gt;s r&lt;grey&gt;  or  &lt;cyan&gt;stat reset&lt;grey&gt;   reset/enable stats for last X minutes\n")
	cecho("    &lt;cyan&gt;s h&lt;grey&gt;  or  &lt;cyan&gt;stat hide&lt;grey&gt;    hide stats for last X minutes\n")
end


-- this is called from alias
function stats.control(command)
	-- help
	if "help" == command then
		stats.showHelp()
	elseif "?" == command then
		stats.showHelp()
	-- print
	elseif "print" == command then
		stats.printAll()
	elseif "p" == command then
		stats.printAll()
	-- reset
	elseif "reset" == command then
		stats.printAll()
		cecho("&lt;cyan&gt;Statistics were reset!\n\n")
		stats.reset(stats.area, "Statistics")
	elseif "r" == command then
		stats.printAll()
		cecho("&lt;cyan&gt;Statistics were reset!\n\n")
		stats.reset(stats.area, "Statistics")
	-- hide
	elseif "hide" == command then
		stats.area.print = false
		cecho("&lt;cyan&gt;Statistics for last X minutes are now hidden!\n\n")
	elseif "h" == command then
		stats.area.print = false
		cecho("&lt;cyan&gt;Statistics for last X minutes are now hidden!\n\n")
	end
end


-- init on session start
if not stats.alreadyInitialized then
	stats.alreadyInitialized = true
	stats.reset(stats.session, "Session statistics")
	stats.reset(stats.area, "Statistics")
	stats.area.print = false  -- same as session, so we don't want to print it out
	stats.timer()
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Re-SpellUp</name>
					<packageName></packageName>
					<script>
-- spellup package
su = {}


function su._sendCommand()
	utils.hidePrompt()
	send("echo {spellup start}", false)
	send(AConf.Actions.spellUp, false)
	send("echo {spellup end}", false)
	utils.showPrompt()
end


function su.forceSpellUpMe()
	if MAG.c102.afk() then
		send("afk", false)
		su._sendCommand()
		send("afk", false)
	else
		if not MAG.c102.sleepingOrResting() then
			su._sendCommand()
		end
	end
end


function su.reSpellUpMe()
	if AConf.Enabled.ReSpellUp then
		su.forceSpellUpMe()
	end
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>generic_mapper</name>
			<packageName>generic_mapper</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Map Script</name>
				<packageName></packageName>
				<script>-- Jor'Mox's Generic Map Script
-- the script self-updates, changing this value will bring an update to all installations
-- make sure versions.lua has the latest version in it
local version = "2.0.22"

    -- look into options for non-standard door usage for speedwalk
    -- come up with aliases to set translations and custom exits, add appropriate help info

mudlet = mudlet or {}
mudlet.mapper_script = true
map = map or {}

map.help = {[[
    &lt;cyan&gt;Generic Map Script&lt;reset&gt;

    This script allows for semi-automatic mapping using the included triggers.
    While different games can have dramatically different ways of displaying
    information, some effort has been put into giving the script a wide range of
    potential patterns to look for, so that it can work with minimal effort in
    many cases. The script locates the room name by searching up from the
    detected exits line until a prompt is found or it runs out of text to
    search, clearing saved text each time a prompt is detected or a movement
    command is sent, with the room name being set to the last line of text
    found. An accurate prompt pattern is necessary for this to work well, and
    sometimes other text can end up being shown between the prompt and the room
    name, or on the same line as the room name, which can be handled by
    providing appropriate patterns telling the script to ignore that text. Below
    is an overview of the included commands and important events that this
    script uses to work. Additional information on each command or event is
    available in individual help files.

    &lt;cyan&gt;Fundamental Commands:&lt;reset&gt;
        These are commands used to get the mapper functional on a basic level

        &lt;link: show&gt;map show&lt;/link&gt; - Displays or hides a map window
        &lt;link: quick start&gt;map basics&lt;/link&gt; - Shows a quick-start guide with some basic information to
            help get the script working
        &lt;link: 1&gt;map help &lt;optional command name&gt;&lt;/link&gt; - Shows either this help file or the
            help file for the command given
        &lt;link: find prompt&gt;find prompt&lt;/link&gt; - Instructs the script to look for a prompt that matches
            a known pattern
        &lt;link: prompt&gt;map prompt&lt;/link&gt; - Provides a specific pattern to the script that matches
            your prompt, uses Lua string-library patterns
        &lt;link: ignore&gt;map ignore&lt;/link&gt; - Provides a specific pattern for the script to ignore,
            uses Lua string-library patterns
        &lt;link: debug&gt;map debug&lt;/link&gt; - Toggles on debug mode, in which extra messages are shown
            with the intent of assisting in troubleshooting getting the
            script setup
        &lt;link: me&gt;map me&lt;/link&gt; - Locates the user on the map, if possible
        &lt;link: path&gt;map path &lt;room name&gt; &lt;; optional area name&gt;&lt;/link&gt; - Finds a walking path to
            the named room, in the named area if specified
        &lt;link: character&gt;map character &lt;name&gt;&lt;/link&gt; - Sets a given name as the current character for
            the purposes of the script, used for different prompt patterns
            and recall locations
        &lt;link: recall&gt;map recall&lt;/link&gt; - Sets the current room as the recall location of the
            current character
        &lt;link: config&gt;map config &lt;configuration&gt; &lt;optional value&gt;&lt;/link&gt; - Sets or toggles the
            given configuration either turning it on or off, if no value is
            given, or sets it to the given value
        &lt;link: window&gt;map window &lt;configuration&gt; &lt;value&gt;&lt;/link&gt; - Sets the given configuration for
            the map window to the given value
        &lt;link: translate&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;&lt;/link&gt;
            &lt;link: translate&gt;&lt;translated short direction&gt;&lt;/link&gt; - Sets the provided translations for
            the given english direction word.

    &lt;cyan&gt;Mapping Commands:&lt;reset&gt;
        These are commands used in the process of actually creating a map

        &lt;link: start mapping&gt;start mapping &lt;optional area name&gt;&lt;/link&gt; - Starts adding content to the
            map, using either the area of the room the user is currently in,
            or the area name provided
        &lt;link: stop mapping&gt;stop mapping&lt;/link&gt; - Stops adding content to the map
        &lt;link: set area&gt;set area &lt;area name&gt;&lt;/link&gt; - Moves the current room to the named area
        &lt;link: mode&gt;map mode &lt;lazy, simple, normal or complex&gt;&lt;/link&gt; - Sets the mapping mode, which
            defines how new rooms are added to the map.
        &lt;link: add door&gt;add door &lt;direction&gt; &lt;optional door status&gt; &lt;optional one way&gt;&lt;/link&gt; -
            Creates a door in the given direction, with the given status
            (default closed), in both directions, unless a one-direction door
            is specified
        &lt;link: add portal&gt;add portal &lt;entry command&gt;&lt;/link&gt; - Creates a portal in the current room,
            using the given command for entry
        &lt;link: shift&gt;shift &lt;direction&gt;&lt;/link&gt; - Moves the current room on the map in the given
            direction
        &lt;link: merge rooms&gt;merge rooms&lt;/link&gt; - Combines overlapping rooms that have the same name into
            a single room
        &lt;link: clear moves&gt;clear moves&lt;/link&gt; - Clears the list of movement commands maintained by the
            script
        &lt;link: set exit&gt;set exit &lt;direction&gt; &lt;roomID&gt;&lt;/link&gt; - Creates a one-way exit in the given
            direction to the room with the specified roomID, can also be used
            with portals
        &lt;link: areas&gt;map areas&lt;/link&gt; - Shows a list of all area, with links to show a list of
            rooms in the area
        &lt;link: rooms&gt;map rooms &lt;area name&gt;&lt;/link&gt; - Shows a list of rooms in the named area

    &lt;cyan&gt;Sharing and Backup Commands:&lt;reset&gt;

        &lt;link: save&gt;map save&lt;/link&gt; - Creates a backup of the map
        &lt;link: load&gt;map load &lt;remote address&gt;&lt;/link&gt; - Loads a map backup, or a map file from a
            remote address
        &lt;link: export&gt;map export &lt;area name&gt;&lt;/link&gt; - Creates a file from the named area that can
            be shared
        &lt;link: import&gt;map import &lt;area name&gt;&lt;/link&gt; - Loads an area from a file

    &lt;cyan&gt;Mapping Events:&lt;reset&gt;
        These events are used by triggers to direct the script's behavior

        &lt;link: onNewRoom&gt;onNewRoom&lt;/link&gt; - Signals that a room has been detected, optional exits
            argument
        &lt;link: onMoveFail&gt;onMoveFail&lt;/link&gt; - Signals that an attempted move failed
        &lt;link: onForcedMove&gt;onForcedMove&lt;/link&gt; - Signals that the character moved without a command
            being entered, required direction argument
        &lt;link: onRandomMove&gt;onRandomMove&lt;/link&gt; - Signals that the character moved in an unknown
            direction without a command being entered
        &lt;link: onVisionFail&gt;onVisionFail&lt;/link&gt; - Signals that the character moved but some or all of
            the room information was not able to be gathered

    &lt;cyan&gt;Key Variables:&lt;reset&gt;
        These variables are used by the script to keep track of important
            information

        &lt;yellow&gt;map.prompt.room&lt;reset&gt; - Can be set to specify the room name
        &lt;yellow&gt;map.prompt.exits&lt;reset&gt; - Can be set to specify the room exits
        &lt;yellow&gt;map.character&lt;reset&gt; - Contains the current character name
        &lt;yellow&gt;map.save.recall&lt;reset&gt; - Contains a table of recall roomIDs for all
            characters
        &lt;yellow&gt;map.save.prompt_pattern&lt;reset&gt; - Contains a table of prompt patterns for all
            characters
        &lt;yellow&gt;map.save.ignore_patterns&lt;reset&gt; - Contains a table of patterns of text the
            script ignores
        &lt;yellow&gt;map.configs&lt;reset&gt; - Contains a number of different options that can be set
            to modify script behavior
        &lt;yellow&gt;map.currentRoom&lt;reset&gt; - Contains the roomID of the room your character is
            in, according to the script
        &lt;yellow&gt;map.currentName&lt;reset&gt; - Contains the name of the room your character is in,
            according to the script
        &lt;yellow&gt;map.currentExits&lt;reset&gt; - Contains a table of the exits of the room your
            character is in, according to the script
        &lt;yellow&gt;map.currentArea&lt;reset&gt; - Contains the areaID of the area your character is
            in, according to the script
]]}
map.help.save = [[
    &lt;cyan&gt;Map Save&lt;reset&gt;
        syntax: &lt;yellow&gt;map save&lt;reset&gt;

        This command creates a copy of the current map and stores it in the
        profile folder as map.dat. This can be useful for creating a backup
        before adding new content, in case of problems, and as a way to share an
        entire map at once.
]]
map.help.load = [[
    &lt;cyan&gt;Map Load&lt;reset&gt;
        syntax: &lt;yellow&gt;map load &lt;optional download address&gt;&lt;reset&gt;

        This command replaces the current map with the map stored as map.dat in
        the profile folder. Alternatively, if a download address is provided, a
        map is downloaded from that location and loaded to replace the current
        map. If no filename is given with the download address, the script tries
        to download map.dat. If a filename is given it MUST end with .dat.
]]
map.help.show = [[
    &lt;cyan&gt;Map Show&lt;reset&gt;
        syntax: &lt;yellow&gt;map show&lt;reset&gt;

        This command shows a map window, as specified by the window configs set
        via the &lt;link: window&gt;map window command&lt;/link&gt;. It isn't necessary to use this method to
        show a map window to use this script, any map window will work.
]]
map.help.export = [[
    &lt;cyan&gt;Map Export&lt;reset&gt;
        syntax: &lt;yellow&gt;map export &lt;area name&gt;&lt;reset&gt;

        This command creates a file containing all the informatino about the
        named area and stores it in the profile folder, with a file name based
        on the area name. This file can then be imported, allowing for easy
        sharing of single map areas. The file name will be the name of the area
        in all lower case, with spaces replaced with underscores, and a .dat
        file extension.
]]
map.help.import = [[
    &lt;cyan&gt;Map Import&lt;reset&gt;
        syntax: &lt;yellow&gt;map import &lt;area name&gt;&lt;reset&gt;

        This command imports a file from the profile folder with a name matching
        the name of the file, and uses it to create an area on the map. The area
        name used can be capitalized or not, and may have either spaces or
        underscores between words. The actual area name is stored within the
        file, and is not set by the area name used in this command.
]]
map.help.start_mapping = [[
    &lt;cyan&gt;Start Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;start mapping &lt;optional area name&gt;&lt;reset&gt;

        This command instructs the script to add new content to the map when it
        is seen. When first used, an area name is mandatory, so that an area is
        created for new rooms to be placed in. If used with an area name while
        the map shows the character within a room on the map, that room will be
        moved to be in the named area, if it is not already in it. If used
        without an area name, the room is not moved, and mapping begins in the
        area the character is currently located in.
]]
map.help.stop_mapping = [[
    &lt;cyan&gt;Stop Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;stop mapping&lt;reset&gt;

        This command instructs the script to stop adding new content until
        mapping is resumed at a later time. The map will continue to perform
        other functions.
]]
map.help.find_prompt = [[
    &lt;cyan&gt;Find Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;find prompt&lt;reset&gt;

        This command instructs the script to begin searching newly arriving text
        for something that matches one of its known prompt patterns. If one is
        found, that pattern will be set as the current prompt pattern. This
        should typically be the first command used to set up this script with a
        new profile. If your prompt appears after using this command, but there
        is no message saying that the prompt has been found, it will be
        necessary to use the map prompt command to manually set a pattern.
]]
map.help.prompt = [[
    &lt;cyan&gt;Map Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;map prompt &lt;prompt pattern&gt;&lt;reset&gt;

        This command manually sets a prompt pattern for the script to use.
        Because of the way this script works, the prompt pattern should match
        the entire prompt, so that if the text matching the pattern were
        removed, the line with the prompt would be blank. The patterns must be
        of the type used by the Lua string library. If you are unsure about what
        pattern to use, seek assistance on the Mudlet Forums or the Mudlet
        Discord channel.
]]
map.help.debug = [[
    &lt;cyan&gt;Map Debug&lt;reset&gt;
        syntax: &lt;yellow&gt;map debug&lt;reset&gt;

        This command toggles the map script's debug mode on or off when it is
        used. Debug mode provides some extra messages to help with setting up
        the script and identifying problems to help with troubleshooting. If you
        are getting assistance with setting up this script, using debug mode may
        make the process faster and easier.
]]
map.help.ignore = [[
    &lt;cyan&gt;Map Ignore&lt;reset&gt;
        syntax: &lt;yellow&gt;map ignore &lt;ignore pattern&gt;&lt;reset&gt;

        This command adds the given pattern to a list the script maintains to
        help it locate the room name. Any text that might appear after a command
        is sent to move and before the room name appears, or after the prompt
        and before the room name if several movement commands are sent at once,
        should have an ignore pattern added for it.

        If the given pattern is already in the list of ignore patterns, that
        pattern will be removed from the list.
]]
map.help.areas = [[
    &lt;cyan&gt;Map Areas&lt;reset&gt;
        syntax: &lt;yellow&gt;map areas&lt;reset&gt;

        This command displays a linked list of all areas in the map. When
        clicked, the rooms in the selected area will be displayed, as if the
        'map rooms' command had been used with that area as an argument.
]]
map.help.rooms = [[
    &lt;cyan&gt;Map Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;map rooms &lt;area name&gt;&lt;reset&gt;

        This command shows a list of all rooms in the area, with the roomID and
        the room name, as well as a count of how many rooms are in the area
        total. Note that the area name argument is not case sensitive.
]]
map.help.set_area = [[
    &lt;cyan&gt;Set Area&lt;reset&gt;
        syntax: &lt;yellow&gt;set area &lt;area name&gt;&lt;reset&gt;

        This command move the current room into the named area, creating the
        area if needed.
]]
map.help.mode = [[
    &lt;cyan&gt;Map Mode&lt;reset&gt;
        syntax: &lt;yellow&gt;map mode &lt;lazy, simple, normal, or complex&gt;&lt;reset&gt;

        This command changes the current mapping mode, which determines what
        happens when new rooms are added to the map.

        In lazy mode, connecting exits aren't checked and a room is only added if
        there isn't an adjacent room with the same name.

        In simple mode, if an adjacent room has an exit stub pointing toward the
        newly created room, and the new room has an exit in that direction,
        those stubs are connected in both directions.

        In normal mode (default), the newly created room is connected to the room you left
        from, so long as it has an exit leading in that direction.

        In complex mode, none of the exits of the newly connected room are
        connected automatically when it is created.
]]
map.help.add_door = [[
    &lt;cyan&gt;Add Door&lt;reset&gt;
        syntax: &lt;yellow&gt;add door &lt;direction&gt; &lt;optional none, open, closed, or locked&gt;
        &lt;optional yes or no&gt;&lt;reset&gt;

        This command places a door on the exit in the given direction, or
        removes it if "none" is given as the second argument. The door status is
        set as given by the second argument, default "closed". The third
        argument determines if the door is a one-way door, default "no".
]]
map.help.add_portal = [[
    &lt;cyan&gt;Add Portal&lt;reset&gt;
        syntax: &lt;yellow&gt;add portal &lt;optional -f&gt; &lt;entry command&gt;&lt;reset&gt;

        This command creates a special exit in the current room that is entered
        by using the given entry command. The given entry command is then sent,
        moving to the destination room. If the destination room matches an
        existing room, the special exit will link to that room, and if not a new
        room will be created. If the optional "-f" argument is given, a new room
        will be created for the destination regardless of if an existing room
        matches the room seen when arriving at the destination.
]]
map.help.shift = [[
    &lt;cyan&gt;Shift&lt;reset&gt;
        syntax: &lt;yellow&gt;shift &lt;direction&gt;&lt;reset&gt;

        This command moves the current room one step in the direction given, on
        the map.
]]
map.help.merge_rooms = [[
    &lt;cyan&gt;Merge Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;merge rooms&lt;reset&gt;

        This command combines all rooms that share the same coordinates and the
        same room name into a single room, with all of the exits preserved and
        combined.
]]
map.help.clear_moves = [[
    &lt;cyan&gt;Clear Moves&lt;reset&gt;
        syntax: &lt;yellow&gt;clear moves&lt;reset&gt;

        This command clears the script's queue of movement commands, and is
        intended to be used after you attempt to move while mapping but the
        movement is prevented in some way that is not caught and handled by a
        trigger that raises the onMoveFail event.
]]
map.help.set_exit = [[
    &lt;cyan&gt;Set Exit&lt;reset&gt;
        syntax: &lt;yellow&gt;set exit &lt;direction&gt; &lt;destination roomID&gt;&lt;reset&gt;

        This command sets the exit in the current room in the given direction to
        connect to the target room, as specified by the roomID. This is a
        one-way connection.
]]
map.help.onnewroom = [[
    &lt;cyan&gt;onNewRoom Event&lt;reset&gt;

        This event is raised to inform the script that a room has been detected.
        When raised, a string containing the exits from the detected room should
        be passed as a second argument to the raiseEvent function, unless those
        exits have previously been stored in map.prompt.exits.
]]
map.help.onmovefail = [[
    &lt;cyan&gt;onMoveFail Event&lt;reset&gt;

        This event is raised to inform the script that a move was attempted but
        the character was unable to move in the given direction, causing that
        movement command to be removed from the script's movement queue.
]]
map.help.onforcedmove = [[
    &lt;cyan&gt;onForcedMove Event&lt;reset&gt;

        This event is raised to inform the script that the character moved in a
        specified direction without a command being entered. When raised, a
        string containing the movement direction must be passed as a second
        argument to the raiseEvent function.

        The most common reason for this event to be raised is when a character
        is following someone else.
]]
map.help.onrandommove = [[
    &lt;cyan&gt;onRandomMove Event&lt;reset&gt;

        This event is raised to inform the script that the character has moved
        in an unknown direction. The script will compare the next room seen with
        rooms that are adjacent to the current room to try to determine the best
        match for where the character has gone.

        In some situations, multiple options are equally viable, so mistakes may
        result. The script will automatically keep verifying positioning with
        each step, and automatically correct the shown location on the map when
        possible.
]]
map.help.onvisionfail = [[
    &lt;cyan&gt;onVisionFail Event&lt;reset&gt;

        This event is raised to inform the script that some or all of the room
        information was not able to be gathered, but the character still
        successfully moved between rooms in the intended direction.
]]
map.help.onprompt = [[
    &lt;cyan&gt;onPrompt Event&lt;reset&gt;

        This event can be raised when using a non-conventional setup to trigger
        waiting messages from the script to be displayed. Additionally, if
        map.prompt.exits exists and isn't simply an empty string, raising this
        event will cause the onNewRoom event to be raised as well. This
        functionality is intended to allow people who have used the older
        version of this script to use this script instead, without having to
        modify the triggers they created for it.
]]
map.help.me = [[
    &lt;cyan&gt;Map Me&lt;reset&gt;
        syntax: &lt;yellow&gt;map me&lt;reset&gt;

        This command forces the script to look at the currently captured room
        name and exits, and search for a potentially matching room, moving the
        map if applicable. Note that this command is generally never needed, as
        the script performs a similar search any time the room name and exits
        don't match expectations.
]]
map.help.path = [[
    &lt;cyan&gt;Map Path&lt;reset&gt;
        syntax: &lt;yellow&gt;map path &lt;room name&gt; &lt;; optional area name&gt;&lt;reset&gt;

        This command tries to find a walking path from the current room to the
        named room. If an area name is given, only rooms within that area that
        is given are checked. Neither the room name nore the area name are case
        sensitive, but otherwise an exact match is required. Note that a
        semicolon is required between the room name and area name, if an area
        name is given, but spaces before or after the semicolon are optional.

        Example: &lt;yellow&gt;map path main street ; newbie town&lt;reset&gt;
]]
map.help.character = [[
    &lt;cyan&gt;Map Character&lt;reset&gt;
        syntax: &lt;yellow&gt;map character &lt;name&gt;&lt;reset&gt;

        This command tells the script what character is currently being used.
        Setting a character is optional, but recall locations and prompt
        patterns are stored by character name, so using this command allows for
        easy switching between different setups. The name given is stored in
        map.character. The name is a case sensitive exact match. The value of
        map.character is not saved between sessions, so this must be set again
        if needed each time the profile is opened.
]]
map.help.recall = [[
    &lt;cyan&gt;Map Recall&lt;reset&gt;
        syntax: &lt;yellow&gt;map recall&lt;reset&gt;

        This command tells the script that the current room is the recall point
        for the current character, as stored in map.character. This information
        is stored in map.save.recall[map.character], and is remembered between
        sessions.
]]
map.help.config = [[
    &lt;cyan&gt;Map Config&lt;reset&gt;
        syntax: &lt;yellow&gt;map config &lt;setting&gt; &lt;optional value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below.
        If no value is given, and the setting is either 'on' or 'off', then the
        value is switched. When naming a setting, spaces can be used in place of
        underscores. Details of what options are available and what each one
        does are provided.

        &lt;yellow&gt;speedwalk_delay&lt;reset&gt; - When using the speedwalk function of the script,
            this is the amount of time the script waits after either sending
            a command or, if speedwalk_wait is set, after arriving in a new
            room, before the next command is sent. This may be any number 0
            or higher.

        &lt;yellow&gt;speedwalk_wait&lt;reset&gt; - When using the speedwalk function of the script,
            this indicates if the script waits for your character to move
            into a new room before sending the next command. This may be true
            or false.

        &lt;yellow&gt;speedwalk_random&lt;reset&gt; - When using the speedwalk function of the script
            with a speedwalk_delay value, introduces a randomness to the wait
            time by adding some amount up to the speedwalk_delay value. This
            may be true or false.

        &lt;yellow&gt;stretch_map&lt;reset&gt; - When adding a new room that would overlap an existing
            room, if this is set the map will stretch out to prevent the
            overlap, with all rooms further in the direction moved getting
            pushed one further in that direction. This may be true or false.

        &lt;yellow&gt;max_search_distance&lt;reset&gt; - When mapping, this is the maximum number of
            rooms that the script will search in the movement direction for a
            matching room before deciding to create a new room. This may be
            false, or any positive whole number. This can also be set to 0,
            which is the same as setting it to false.

        &lt;yellow&gt;search_on_look&lt;reset&gt; - When this is set, using the "look" command causes
            the map to verify your position using the room name and exits
            seen following using the command. This may be true or false.
            
        &lt;yellow&gt;clear_lines_on_send&lt;reset&gt; - When this is set, any time a command is sent,
            any lines stored from the game used to search for the room name
            are cleared. This may be true or false.

        &lt;yellow&gt;mode&lt;reset&gt; - This is the default mapping mode on startup, and defines how
            new rooms are added to the map. May be "lazy", "simple",
            "normal" or "complex".
            
        &lt;yellow&gt;download_path&lt;reset&gt; - This is the path that updates are downloaded from.
            This may be any web address where the versions.lua and
            generic_mapper.xml files can be downloaded from.

        &lt;yellow&gt;prompt_test_patterns&lt;reset&gt; - This is a table of default patterns checked
            when using the "find prompt" command. The patterns in this table
            should start with a '^', and be written to be used with the Lua
            string library. Most importantly, '%' is used as the escape
            character instead of '\' as in trigger regex patterns.

        &lt;yellow&gt;custom_exits&lt;reset&gt; - This is a table of custom exit directions and their
            relevant extra pieces of info. Each entry should have the short
            direction as the keyword for a table containing first the long
            direction, then the long direction of the reverse of this
            direction, and then the x, y, and z change in map position
            corresponding to the movement. As an example: us = {'upsouth',
            'downnorth', 0, -1, 1}

        &lt;yellow&gt;custom_name_search&lt;reset&gt; - When this is set, instead of running the default
            function name_search, a user-defined function called
            'mudlet.custom_name_search' is used instead. This may be true or false.
            
        &lt;yellow&gt;use_translation&lt;reset&gt; - When this is set, the lang_dirs table is used to
            translate movement and status commands in some other language
            into the English used by the script. This may be true or false.

        &lt;yellow&gt;debug&lt;reset&gt; - When this is set, the script will start in debug mode. This
            may be true or false.
]]
map.help.window = [[
    &lt;yellow&gt;Map Window&lt;reset&gt;
        syntax: &lt;yellow&gt;map window &lt;setting&gt; &lt;value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below,
        which determine the appearance and positioning of the map window when
        the 'map show' command is used. Details of what options are available
        and what each one does are provided.

        &lt;yellow&gt;x&lt;reset&gt; - This is the x position of the map window, and should be a
            positive number of pixels or a percentage of the screen width.

        &lt;yellow&gt;y&lt;reset&gt; - This is the y position of the map window, and should be a
            positive number of pixels or a percentage of the screen height.

        &lt;yellow&gt;w&lt;reset&gt; - This is the width of the map window, and should be a positive
            number of pixels or a percentage of the screen width.

        &lt;yellow&gt;h&lt;reset&gt; - This is the height of the map window, and should be a positive
            number of pixels or a percentage of the screen height.

        &lt;yellow&gt;origin&lt;reset&gt; - This is the corner from which the window position is
            measured, and may be 'topright', 'topleft', 'bottomright', or
            'bottomleft'.

        &lt;yellow&gt;shown&lt;reset&gt; - This determines if the map window is shown immediately upon
            connecting to the game. This may be true or false. If you intend
            to have some other script control the map window, this should be
            set to false.
]]
map.help.translate = [[
    &lt;yellow&gt;Map Translate&lt;reset&gt;
        syntax: &lt;yellow&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;
            &lt;translated short direction&gt;&lt;reset&gt;

        This command sets direction translations for the script to use, either
        for commands entered to move around, or listed exits the game shows when
        you enter a room. Available directions: north, south, east, west,
        northwest, northeast, southwest, southeast, up, down, in, and out.
        Also you can customize special commands sent to mud like 'look'.
]]
map.help.quick_start = [[
    &lt;link: quick_start&gt;map basics&lt;/link&gt; (quick start guide)
    ----------------------------------------

    Mudlet Mapper works in tandem with a script, and this generic mapper script needs
    to know 2 things to work:
      - &lt;dim_grey&gt;room name&lt;reset&gt; $ROOM_NAME_STATUS ($ROOM_NAME)
      - &lt;dim_grey&gt;exits&lt;reset&gt;     $ROOM_EXITS_STATUS ($ROOM_EXITS)

    1. &lt;link: start mapping&gt;start mapping &lt;optional area name&gt;&lt;/link&gt;
       If both room name and exits are good, you can start mapping! Give it the
       area name you're currently in, usually optional but required for the first one.
    2. &lt;link: find prompt&gt;find prompt&lt;/link&gt;
       Room name or exits aren't recognised? Try this command then. It will make
       the script start looking for a prompt using several standard prompt
       patterns. If a prompt is found, you will be notified, if not, you will
       need to set a prompt pattern yourself using &lt;link: prompt&gt;map prompt&lt;/link&gt;.
       Reach out to the &lt;urllink: https://discord.gg/kuYvMQ9&gt;Mudlet community&lt;/urllink&gt; for help, we'd be happy to help
       you figure it out!
    3. &lt;link: debug&gt;map debug&lt;/link&gt;
       This toggles debug mode. When on, messages will be displayed showing what
       information is captured and a few additional error messages that can help
       with getting the script fully compatible with your game.
    4. &lt;link: 1&gt;map help&lt;/link&gt;
       This will bring up a more detailed help file, starting with the available
       help topics.
]]

map.character = map.character or ""
map.prompt = map.prompt or {}
map.save = map.save or {}
map.save.recall = map.save.recall or {}
map.save.prompt_pattern = map.save.prompt_pattern or {}
map.save.ignore_patterns = map.save.ignore_patterns or {}

local oldstring = string
local string = utf8
string.format = oldstring.format
string.trim = oldstring.trim
string.starts = oldstring.starts
string.split = oldstring.split
string.ends = oldstring.ends


local profilePath = getMudletHomeDir()
profilePath = profilePath:gsub("\\","/")

map.defaults = {
    mode = "normal", -- can be lazy, simple, normal, or complex
    stretch_map = true,
    search_on_look = true,
    speedwalk_delay = 1,
    speedwalk_wait = true,
    speedwalk_random = true,
    max_search_distance = 1,
    clear_lines_on_send = true,
    map_window = {x = 0,
        y = 0,
        w = "30%",
        h = "40%",
        origin = "topright",
        shown = false,
    },
    prompt_test_patterns = {"^%[?%a*%]?&lt;.*&gt;", "^%[.*%]%s*&gt;", "^%w*[%.?!:]*&gt;", "^%[.*%]", "^[Hh][Pp]:.*&gt;"},
    custom_exits = {},  -- format: short_exit = {long_exit, reverse_exit, x_dif, y_dif, z_dif}
                        -- ex: { us = {"upsouth", "downnorth", 0, -1, 1}, dn = {"downnorth", "upsouth", 0, 1, -1} }
    custom_name_search = false,
    use_translation = true,
    lang_dirs = {n = 'n', ne = 'ne', nw = 'nw', e = 'e', w = 'w', s = 's', se = 'se', sw = 'sw',
        u = 'u', d = 'd', ["in"] = 'in', out = 'out', north = 'north', northeast = 'northeast',
        east = 'east', west = 'west', south = 'south', southeast = 'southeast', southwest = 'southwest',
        northwest = 'northwest', up = 'up', down = 'down', l = 'l', look = 'look',
    },
    debug = false,
    download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper",
}

local move_queue, lines = {}, {}
local find_portal, vision_fail, room_detected, random_move, force_portal, find_prompt, downloading, walking, help_shown
local mt = getmetatable(map) or {}

local function config()
    local defaults = map.defaults
    local configs = map.configs or {}
    local path = profilePath.."/map downloads"
    if not io.exists(path) then lfs.mkdir(path) end
    -- load stored configs from file if it exists
    if io.exists(path.."/configs.lua") then
        table.load(path.."/configs.lua",configs)
    end
    -- overwrite default values with stored config values
    configs = table.update(defaults, configs)
    map.configs = configs
    map.configs.translate = {}
    for k, v in pairs(map.configs.lang_dirs) do
        map.configs.translate[v] = k
    end
    -- incorporate custom exits
    for k,v in pairs(map.configs.custom_exits) do
        exitmap[k] = v[1]
        reverse_dirs[v[1]] = v[2]
        short[v[1]] = k
        local count = #coordmap
        coordmap[count] = {v[3],v[4],v[5]}
        stubmap[count] = v[1]
        stubmap[v[1]] = count
    end
    -- update to the current download path
    if map.configs.download_path == "https://raw.githubusercontent.com/JorMox/Mudlet/development/src/mudlet-lua/lua/generic-mapper" then
        map.configs.download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper"
    end

    -- setup metatable to store sensitive values
    local protected = {"mapping", "currentRoom", "currentName", "currentExits", "currentArea",
        "prevRoom", "prevName", "prevExits", "mode", "version"}
    mt = getmetatable(map) or {}
    mt.__index = mt
    mt.__newindex = function(tbl, key, value)
            if not table.contains(protected, key) then
                rawset(tbl, key, value)
            else
                error("Protected Map Table Value")
            end
        end
    mt.set = function(key, value)
            if table.contains(protected, key) then
                mt[key] = value
            end
        end
    setmetatable(map, mt)
    map.set("mode", configs.mode)
    map.set("version", version)

    local saves = {}
    if io.exists(path.."/map_save.dat") then
        table.load(path.."/map_save.dat",saves)
    end
    saves.prompt_pattern = saves.prompt_pattern or {}
    saves.ignore_patterns = saves.ignore_patterns or {}
    saves.recall = saves.recall or {}
    map.save = saves

    if map.configs.map_window.shown then
        map.showMap(true)
    end
end

local exitmap = {
    n = 'north',    ne = 'northeast',   nw = 'northwest',   e = 'east',
    w = 'west',     s = 'south',        se = 'southeast',   sw = 'southwest',
    u = 'up',       d = 'down',         ["in"] = 'in',      out = 'out',
    l = 'look'
}

local short = {}
for k,v in pairs(exitmap) do
    short[v] = k
end

local stubmap = {
    north = 1,      northeast = 2,      northwest = 3,      east = 4,
    west = 5,       south = 6,          southeast = 7,      southwest = 8,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    [1] = "north",  [2] = "northeast",  [3] = "northwest",  [4] = "east",
    [5] = "west",   [6] = "south",      [7] = "southeast",  [8] = "southwest",
    [9] = "up",     [10] = "down",      [11] = "in",        [12] = "out",
}

local coordmap = {
    [1] = {0,1,0},      [2] = {1,1,0},      [3] = {-1,1,0},     [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},     [7] = {1,-1,0},     [8] = {-1,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},    [11] = {0,0,0},     [12] = {0,0,0},
}

local reverse_dirs = {
    north = "south", south = "north", west = "east", east = "west", up = "down",
    down = "up", northwest = "southeast", northeast = "southwest", southwest = "northeast",
    southeast = "northwest", ["in"] = "out", out = "in",
}

local wait_echo = {}
local mapper_tag = "&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;"
local debug_tag = "&lt;255,165,0&gt;(&lt;200,120,0&gt;debug&lt;255,165,0&gt;): &lt;255,255,255&gt;"
local err_tag = "&lt;255,0,0&gt;(&lt;178,34,34&gt;error&lt;255,0,0&gt;): &lt;255,255,255&gt;"


local function parse_help_text(text)
  text = text:gsub("%$ROOM_NAME_STATUS", (map.currentName and map.currentName ~= "") and '✔️' or '❌')
  text = text:gsub("%$ROOM_NAME", map.currentName or '')

  text = text:gsub("%$ROOM_EXITS_STATUS", (not map.currentExits or table.is_empty(map.currentExits)) and '❌' or '✔️')
  text = text:gsub("%$ROOM_EXITS", map.currentExits and table.concat(map.currentExits, ' ') or '')

  return text
end

function map.show_help(cmd)
    if cmd and cmd ~= "" then
        if cmd:starts("map ") then cmd = cmd:sub(5) end
        cmd = cmd:lower():gsub(" ","_")
        if not map.help[cmd] then
            map.echo("No help file on that command.")
        end
    else
        cmd = 1
    end

    for w in parse_help_text(map.help[cmd]):gmatch("[^\n]*\n") do
        local url, target = rex.match(w, [[&lt;(url)?link: ([^&gt;]+)&gt;]])
        -- lrexlib returns a non-capture as 'false', so determine which variable the capture went into
        if target == nil then target = url end
        if target then
            local before, linktext, _, link, _, after, ok = rex.match(w,
                          [[(.*)&lt;((url)?link): [^&gt;]+&gt;(.*)&lt;\/(url)?link&gt;(.*)]], 0, 'm')
            -- could not get rex.match to capture the newline - fallback to string.match
            local _, _, after = w:match("(.*)&lt;u?r?l?link: [^&gt;]+&gt;(.*)&lt;/u?r?l?link&gt;(.*)")

            cecho(before)
            fg("yellow")
            setUnderline(true)
            if linktext == "urllink" then
                echoLink(link, [[openWebPage("]]..target..[[")]], "Open Mudlet Discord", true)
            elseif target ~= "1" then
                echoLink(link,[[map.show_help("]]..target..[[")]],"View: map help " .. target,true)
            else
                echoLink(link,[[map.show_help()]],"View: map help",true)
            end
            setUnderline(false)
            resetFormat()
            if after then cecho(after) end
        else
            cecho(w)
        end
    end
    echo("\n")
end

local bool_configs = {'stretch_map', 'search_on_look', 'speedwalk_wait', 'speedwalk_random',
    'clear_lines_on_send', 'debug', 'custom_name_search', 'use_translation'}
-- function intended to be used by an alias to change config values and save them to a file for later
function map.setConfigs(key, val, sub_key)
    if val == "off" or val == "false" then
        val = false
    elseif val == "on" or val == "true" then
        val = true
    end
    local toggle = false
    if val == nil or val == "" then toggle = true end
    key = key:gsub(" ","_")
    if tonumber(val) then val = tonumber(val) end
    if not toggle then
        if key == "map_window" then
            if map.configs.map_window[sub_key] then
                map.configs.map_window[sub_key] = val
                map.echo(string.format("Map config %s set to: %s", sub_key, tostring(val)))
            else
                map.echo("Unknown map config.",false, true)
            end
        elseif key =="lang_dirs" then
            sub_key = exitmap[sub_key] or sub_key
            if map.configs.lang_dirs[sub_key] then
                local long_dir, short_dir = val[1],val[2]
                if #long_dir &lt; #short_dir then long_dir, short_dir = short_dir, long_dir end
                map.configs.lang_dirs[sub_key] = long_dir
                map.configs.lang_dirs[short[sub_key]] = short_dir
                map.echo(string.format("Direction/command %s, abbreviated as %s, now interpreted as %s.", long_dir, short_dir, sub_key))
                map.configs.translate = {}
                for k, v in pairs(map.configs.lang_dirs) do
                    map.configs.translate[v] = k
                end
            else
                map.echo("Invalid direction/command.", false, true)
            end
        elseif key == "prompt_test_patterns" then
            if not table.contains(map.configs.prompt_test_patterns) then
                table.insert(map.configs.prompt_test_patterns, val)
                map.echo("Prompt pattern added to list: " .. val)
            else
                table.remove(map.configs.prompt_test_patterns, table.index_of(map.configs.prompt_test_patterns, val))
                map.echo("Prompt pattern removed from list: " .. val)
            end
        elseif key == "custom_exits" then
            if type(val) == "table" then
                for k, v in pairs(val) do
                    map.configs.custom_exit[k] = v
                    map.echo(string.format("Custom Exit short direction %s, long direction %s",k,v[1]))
                    map.echo(string.format("    set to: x: %s, y: %s, z: %s, reverse: %s",v[3],v[4],v[5],v[2]))
                end
            else
                map.echo("Custom Exit config must be in the form of a table.", false, true)
            end
        elseif map.configs[key] ~= nil then
            map.configs[key] = val
            map.echo(string.format("Config %s set to: %s", key, tostring(val)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    elseif toggle then
        if (type(map.configs[key]) == "boolean" and table.contains(bool_configs, key)) then
            map.configs[key] = not map.configs[key]
            map.echo(string.format("Config %s set to: %s", key, tostring(map.configs[key])))
        elseif key == "map_window" and sub_key == "shown" then
            map.configs.map_window.shown = not map.configs.map_window.shown
            map.echo(string.format("Map config %s set to: %s", "shown", tostring(map.configs.map_window.shown)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    end
    table.save(profilePath.."/map downloads/configs.lua",map.configs)
    config()
end

local function show_err(msg,debug)
    map.echo(msg,debug,true)
    error(msg,2)
end

local function print_echoes(what, debug, err)
    moveCursorEnd("main")
    local curline = getCurrentLine()
    if curline ~= "" then echo("\n") end
    decho(mapper_tag)
    if debug then decho(debug_tag) end
    if err then decho(err_tag) end
    cecho(what)
    echo("\n")
end

local function print_wait_echoes()
    for k,v in ipairs(wait_echo) do
        print_echoes(v[1],v[2],v[3])
    end
    wait_echo = {}
end

function map.echo(what, debug, err, wait)
    if debug and not map.configs.debug then return end
    what = tostring(what) or ""
    if wait then
        table.insert(wait_echo,{what, debug, err})
        return
    end
    print_wait_echoes()
    print_echoes(what, debug, err)
end

local function set_room(roomID)
    -- moves the map to the new room
    if map.currentRoom ~= roomID then
        map.set("prevRoom", map.currentRoom)
        map.set("currentRoom", roomID)
    end
    if getRoomName(map.currentRoom) ~= map.currentName then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        map.set("currentName", getRoomName(map.currentRoom))
        map.set("currentExits", getRoomExits(map.currentRoom))
        -- check handling of custom exits here
        for i = 13,#stubmap do
            map.currentExits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
        end
    end
    map.set("currentArea", getRoomArea(map.currentRoom))
    centerview(map.currentRoom)
    raiseEvent("onMoveMap", map.currentRoom)
end

local function add_door(roomID, dir, status)
    -- create or remove a door in the designated direction
    -- consider options for adding pickable and passable information
    dir = exitmap[dir] or dir
    if not table.contains(exitmap,dir) then
        error("Add Door: invalid direction.",2)
    end
    if type(status) ~= "number" then
        status = assert(table.index_of({"none","open","closed","locked"},status),
            "Add Door: Invald status, must be none, open, closed, or locked") - 1
    end
    local exits = getRoomExits(roomID)
    -- check handling of custom exits here
    if not exits[dir] then
        setExitStub(roomID,stubmap[dir],true)
    end
    -- check handling of custom exits here
    if not table.contains({'u','d'},short[dir]) then
        setDoor(roomID,short[dir],status)
    else
        setDoor(roomID,dir,status)
    end
end

local function check_doors(roomID,exits)
    -- looks to see if there are doors in designated directions
    -- used for room comparison, can also be used for pathing purposes
    if type(exits) == "string" then exits = {exits} end
    local statuses = {}
    local doors = getDoors(roomID)
    local dir
    for k,v in pairs(exits) do
        dir = short[k] or short[v]
        if table.contains({'u','d'},dir) then
            dir = exitmap[dir]
        end
        if not doors[dir] or doors[dir] == 0 then
            return false
        else
            statuses[dir] = doors[dir]
        end
    end
    return statuses
end

local function find_room(name, area)
    -- looks for rooms with a particular name, and if given, in a specific area
    local rooms = searchRoom(name)
    if type(area) == "string" then
        local areas = getAreaTable() or {}
        for k,v in pairs(areas) do
            if string.lower(k) == string.lower(area) then
                area = v
                break
            end
        end
        area = areas[area] or nil
    end
    for k,v in pairs(rooms) do
        if string.lower(v) ~= string.lower(name) then
            rooms[k] = nil
        elseif area and getRoomArea(k) ~= area then
            rooms[k] = nil
        end
    end
    return rooms
end

local function getRoomStubs(roomID)
    -- turns stub info into table similar to exit table
    local stubs = getExitStubs(roomID)
    if type(stubs) ~= "table" then stubs = {} end
    -- check handling of custom exits here
    local tmp
    for i = 13,#stubmap do
        tmp = tonumber(getRoomUserData(roomID,"stub"..stubmap[i]))
        if tmp then table.insert(stubs,tmp) end
    end

    local exits = {}
    for k,v in pairs(stubs) do
        exits[stubmap[v]] = 0
    end
    return exits
end

local function connect_rooms(ID1, ID2, dir1, dir2, no_check)
    -- makes a connection between rooms
    -- can make backwards connection without a check
    local match = false
    if not ID1 and ID2 and dir1 then
        error("Connect Rooms: Missing Required Arguments.",2)
    end
    dir2 = dir2 or reverse_dirs[dir1]
    -- check handling of custom exits here
    if stubmap[dir1] &lt;= 12 then
        setExit(ID1,ID2,stubmap[dir1])
    else
        setRoomUserData(ID1,"exit " .. dir1,ID2)
    end
    if stubmap[dir1] &gt; 13 then
        -- check handling of custom exits here
        setRoomUserData(ID1,"stub"..dir1,"")
    end
    local doors1, doors2 = getDoors(ID1), getDoors(ID2)
    local dstatus1, dstatus2 = doors1[short[dir1]] or doors1[dir1], doors2[short[dir2]] or doors2[dir2]
    if dstatus1 ~= dstatus2 then
        if not dstatus1 then
            add_door(ID1,dir1,dstatus2)
        elseif not dstatus2 then
            add_door(ID2,dir2,dstatus1)
        end
    end
    if map.mode ~= "complex" then
        local stubs = getRoomStubs(ID2)
        if stubs[dir2] then match = true end
        if (match or no_check) then
            -- check handling of custom exits here
            if stubmap[dir1] &lt;= 12 then
                setExit(ID2,ID1,stubmap[dir2])
            else
                setRoomUserData(ID2,"exit " .. dir2,ID1)
            end
            if stubmap[dir2] &gt; 13 then
                -- check handling of custom exits here
                setRoomUserData(ID2,"stub"..dir2,"")
            end
        end
    end
end

local function check_room(roomID, name, exits, onlyName)
    -- check to see if room name or/and exits match expectations
    if not roomID then
        error("Check Room Error: No ID",2)
    end
    if name ~= getRoomName(roomID) then return false end
    
    -- used in mode "lazy" to match only the room name
    if onlyName then return true end
    
    local t_exits = table.union(getRoomExits(roomID),getRoomStubs(roomID))
    -- check handling of custom exits here
    for i = 13,#stubmap do
        t_exits[stubmap[i]] = tonumber(getRoomUserData(roomID,"exit " .. stubmap[i]))
    end
    for k,v in ipairs(exits) do
        if short[v] and not table.contains(t_exits,v) then return false end
        t_exits[v] = nil
    end
    return table.is_empty(t_exits) or check_doors(roomID,t_exits)
end

local function stretch_map(dir,x,y,z)
    -- stretches a map to make room for just added room that would overlap with existing room
    local dx,dy,dz
    if not dir then return end
    for k,v in pairs(getAreaRooms(map.currentArea)) do
        if v ~= map.currentRoom then
            dx,dy,dz = getRoomCoordinates(v)
            if dx &gt;= x and string.find(dir,"east") then
                dx = dx + 1
            elseif dx &lt;= x and string.find(dir,"west") then
                dx = dx - 1
            end
            if dy &gt;= y and string.find(dir,"north") then
                dy = dy + 1
            elseif dy &lt;= y and string.find(dir,"south") then
                dy = dy - 1
            end
            if dz &gt;= z and string.find(dir,"up") then
                dz = dz + 1
            elseif dz &lt;= z and string.find(dir,"down") then
                dz = dz - 1
            end
            setRoomCoordinates(v,dx,dy,dz)
        end
    end
end

local function create_room(name, exits, dir, coords)
    -- makes a new room with captured name and exits
    -- links with other rooms as appropriate
    -- links to adjacent rooms in direction of exits if in simple mode
    if map.mapping then
        name = map.sanitizeRoomName(name)
        map.echo("New Room: " .. name,false,false,(dir or find_portal or force_portal) and true or false)
        local newID = createRoomID()
        addRoom(newID)
        setRoomArea(newID, map.currentArea)
        setRoomName(newID, name)
        for k,v in ipairs(exits) do
            if stubmap[v] then
                if stubmap[v] &lt;= 12 then
                    setExitStub(newID, stubmap[v], true)
                else
                    -- check handling of custom exits here
                    setRoomUserData(newID, "stub"..v,stubmap[v])
                end
            end
        end
        if dir then
            connect_rooms(map.currentRoom, newID, dir)
        elseif find_portal or force_portal then
            addSpecialExit(map.currentRoom, newID, (find_portal or force_portal))
            setRoomUserData(newID,"portals",tostring(map.currentRoom)..":"..(find_portal or force_portal))
        end
        setRoomCoordinates(newID,unpack(coords))
        local pos_rooms = getRoomsByPosition(map.currentArea,unpack(coords))
        if not (find_portal or force_portal) and map.configs.stretch_map and table.size(pos_rooms) &gt; 1 then
            set_room(newID)
            stretch_map(dir,unpack(coords))
        end
        if map.mode == "simple" then
            local x,y,z = unpack(coords)
            local dx,dy,dz,rooms
            for k,v in ipairs(exits) do
                if stubmap[v] then
                    dx,dy,dz = unpack(coordmap[stubmap[v]])
                    rooms = getRoomsByPosition(map.currentArea,x+dx,y+dy,z+dz)
                    if table.size(rooms) == 1 then
                        connect_rooms(newID,rooms[0],v)
                    end
                end
            end
        end
        set_room(newID)
    end
end

local function find_area_limits(areaID)
    -- used to find min and max coordinate limits for an area
    if not areaID then
        error("Find Limits: Missing area ID",2)
    end
    local rooms = getAreaRooms(areaID)
    local minx, miny, minz = getRoomCoordinates(rooms[0])
    local maxx, maxy, maxz = minx, miny, minz
    local x,y,z
    for k,v in pairs(rooms) do
        x,y,z = getRoomCoordinates(v)
        minx = math.min(x,minx)
        maxx = math.max(x,maxx)
        miny = math.min(y,miny)
        maxy = math.max(y,maxy)
        minz = math.min(z,minz)
        maxz = math.max(z,maxz)
    end
    return minx, maxx, miny, maxy, minz, maxz
end

local function find_link(name, exits, dir, max_distance)
    -- search for matching room in desired direction
    -- in lazy mode check_room search only by name
    local x,y,z = getRoomCoordinates(map.currentRoom)
    if map.mapping and x then
        if max_distance &lt; 1 then
            max_distance = nil
        else
            max_distance = max_distance - 1
        end
        if not stubmap[dir] or not coordmap[stubmap[dir]] then return end
        local dx,dy,dz = unpack(coordmap[stubmap[dir]])
        local minx, maxx, miny, maxy, minz, maxz = find_area_limits(map.currentArea)
        local rooms, match, stubs
        if max_distance then
            minx, maxx = x - max_distance, x + max_distance
            miny, maxy = y - max_distance, y + max_distance
            minz, maxz = z - max_distance, z + max_distance
        end
        repeat
            x, y, z = x + dx, y + dy, z + dz
            rooms = getRoomsByPosition(map.currentArea,x,y,z)
        until (x &gt; maxx or x &lt; minx or y &gt; maxy or y &lt; miny or z &gt; maxz or z &lt; minz or not table.is_empty(rooms))
        for k,v in pairs(rooms) do
            if check_room(v,name,exits,false) then
                match = v
                break            
            elseif map.mode == "lazy" and check_room(v,name,exits,true) then
                match = v
                break
            end
        end
        if match then
            connect_rooms(map.currentRoom, match, dir)
            set_room(match)
        else
            x,y,z = getRoomCoordinates(map.currentRoom)
            create_room(name, exits, dir,{x+dx,y+dy,z+dz})
        end
    end
end

local function move_map()
    -- tries to move the map to the next room
    local move = table.remove(move_queue,1)
    if move or random_move then
        local exits = (map.currentRoom and getRoomExits(map.currentRoom)) or {}
        -- check handling of custom exits here
        if map.currentRoom then
            for i = 13, #stubmap do
                exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
            end
        end
        local special = (map.currentRoom and getSpecialExitsSwap(map.currentRoom)) or {}
        if move and not exits[move] and not special[move] then
            for k,v in pairs(special) do
                if string.starts(k,move) then
                    move = k
                    break
                end
            end
        end
        if find_portal then
            map.find_me(map.currentName,map.currentExits,move)
            find_portal = false
        elseif force_portal then
            find_portal = false
            map.echo("Creating portal destination")
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
            force_portal = false
        elseif move == "recall" and map.save.recall[map.character] then
            set_room(map.save.recall[map.character])
        elseif move == map.configs.lang_dirs['look'] and map.currentRoom and not check_room(map.currentRoom, map.currentName, map.currentExits) then
            -- this check isn't working as intended, find out why
            map.find_me(map.currentName,map.currentExits)
        else
        	local onlyName
            if map.mode == "lazy" then
              onlyName = true
            else
              onlyName = false
            end 
            if exits[move] and (vision_fail or check_room(exits[move], map.currentName, map.currentExits, onlyName)) then
                set_room(exits[move])
            elseif special[move] and (vision_fail or check_room(special[move], map.currentName, map.currentExits, onlyName)) then
                set_room(special[move])
            elseif not vision_fail then
                if map.mapping and move then
                    find_link(map.currentName, map.currentExits, move, map.configs.max_search_distance)
                else
                    map.find_me(map.currentName,map.currentExits, move)
                end
            end
        end
        vision_fail = false
    end
end

local function capture_move_cmd(dir,priority)
    -- captures valid movement commands
    local configs = map.configs
    if configs.clear_lines_on_send then
        lines = {}
    end
    dir = string.lower(dir)
    if dir == "/" then dir = "recall" end
    if dir == configs.lang_dirs['l'] then dir = configs.lang_dirs['look'] end
    if configs.use_translation then
        dir = configs.translate[dir] or dir
    end
    local door = string.match(dir,"open (%a+)")
    if map.mapping and door and (exitmap[door] or short[door]) then
        local doors = getDoors(map.currentRoom)
        if not doors[door] and not doors[short[door]] then
            map.set_door(door,"","")
        end
    end
    local portal = string.match(dir,"enter (%a+)")
    if map.mapping and portal then
        local portals = getSpecialExitsSwap(map.currentRoom)
        if not portals[dir] then
            map.set_portal(dir, true)
        end
    end
    if table.contains(exitmap,dir) or string.starts(dir,"enter ") or dir == "recall" then
        if priority then
            table.insert(move_queue,1,exitmap[dir] or dir)
        else
            table.insert(move_queue,exitmap[dir] or dir)
        end
    elseif configs.search_on_look and dir == configs.lang_dirs['look'] then
        table.insert(move_queue, dir)
    elseif map.currentRoom then
        local special = getSpecialExitsSwap(map.currentRoom) or {}
        if special[dir] then
            if priority then
                table.insert(move_queue,1,dir)
            else
                table.insert(move_queue,dir)
            end
        end
    end
end

local function deduplicate_exits(exits)
  local deduplicated_exits = {}
  for _, v in ipairs(exits) do
    deduplicated_exits[v] = true
  end

  return table.keys(deduplicated_exits)
end
local function capture_room_info(name, exits)
    -- captures room info, and tries to move map to match
    if (not vision_fail) and name and exits then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        name = string.trim(name)
        map.set("currentName", name)
        if exits:ends(".") then exits = exits:sub(1,#exits-1) end
        if not map.configs.use_translation then
            exits = string.gsub(string.lower(exits)," and "," ")
        end
        map.set("currentExits", {})
        for w in string.gmatch(exits,"%a+") do
            if map.configs.use_translation then
                local dir = map.configs.translate and map.configs.translate[w]
                if dir then table.insert(map.currentExits,dir) end
            else
                table.insert(map.currentExits,w)
            end
        end
    undupeExits = deduplicate_exits(map.currentExits)
    map.set("currentExits", undupeExits)
        map.echo(string.format("Exits Captured: %s (%s)",exits, table.concat(map.currentExits, " ")),true)
        move_map()
    elseif vision_fail then
        move_map()
    end
end

local function find_area(name)
    -- searches for the named area, and creates it if necessary
    local areas = getAreaTable()
    local areaID
    for k,v in pairs(areas) do
        if string.lower(name) == string.lower(k) then
            areaID = v
            break
        end
    end
    if not areaID then areaID = addAreaName(name) end
    if not areaID then
        show_err("Invalid Area. No such area found, and area could not be added.",true)
    end
    map.set("currentArea", areaID)
end

function map.load_map(address)
    local path = profilePath .. "/map downloads/map.dat"
    if not address then
        loadMap(path)
        map.echo("Map reloaded from local copy.")
    else
        if not string.match(address,"/[%a_]+%.dat$") then
            address = address .. "/map.dat"
        end
        downloading = true
        downloadFile(path, address)
        map.echo(string.format("Downloading map file from: %s.",address))
    end
end

function map.set_exit(dir,roomID)
    -- used to set unusual exits from the room you are standing in
    if map.mapping then
        roomID = tonumber(roomID)
        if not roomID then
            show_err("Set Exit: Invalid Room ID")
        end
        if not table.contains(exitmap,dir) and not string.starts(dir, "-p ") then
            show_err("Set Exit: Invalid Direction")
        end

        if not string.starts(dir, "-p ") then
            local exit
            if stubmap[exitmap[dir] or dir] &lt;= 12 then
                exit = short[exitmap[dir] or dir]
                setExit(map.currentRoom,roomID,exit)
            else
                -- check handling of custom exits here
                exit = exitmap[dir] or dir
                exit = "exit " .. exit
                setRoomUserData(map.currentRoom,exit,roomID)
            end
            map.echo("Exit " .. dir .. " now goes to roomID " .. roomID)
        else
            dir = string.gsub(dir,"^-p ","")
            addSpecialExit(map.currentRoom,roomID,dir)
            map.echo("Special exit '" .. dir .. "' now goes to roomID " .. roomID)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.find_path(roomName,areaName,return_tables)
    areaName = (areaName ~= "" and areaName) or nil
    local rooms = find_room(roomName,areaName)
    local found,dirs = false,{}
    local path = {}
    for k,v in pairs(rooms) do
        found = getPath(map.currentRoom,k)
        if found and (#dirs == 0 or #dirs &gt; #speedWalkDir) then
            dirs = speedWalkDir
            path = speedWalkPath
        end
    end
    if return_tables then
        if table.is_empty(path) then
            path, dirs = nil, nil
        end
        return path, dirs
    else
        if #dirs &gt; 0 then
            map.echo("Path to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ": " .. table.concat(dirs,", "))
        else
            map.echo("No path found to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ".",false,true)
        end
    end
end

function map.export_area(name)
    -- used to export a single area to a file
    local areas = getAreaTable()
    name = string.lower(name)
    for k,v in pairs(areas) do
        if name == string.lower(k) then name = k end
    end
    if not areas[name] then
        show_err("No such area.")
    end
    local rooms = getAreaRooms(areas[name])
    local tmp = {}
    for k,v in pairs(rooms) do
        tmp[v] = v
    end
    rooms = tmp
    local tbl = {}
    tbl.name = name
    tbl.rooms = {}
    tbl.exits = {}
    tbl.special = {}
    local rname, exits, stubs, doors, special, portals, door_up, door_down, coords
    for k,v in pairs(rooms) do
        rname = getRoomName(v)
        exits = getRoomExits(v)
        stubs = getExitStubs(v)
        doors = getDoors(v)
        special = getSpecialExitsSwap(v)
        portals = getRoomUserData(v,"portals") or ""
        coords = {getRoomCoordinates(v)}
        tbl.rooms[v] = {name = rname, coords = coords, exits = exits, stubs = stubs, doors = doors, door_up = door_up,
            door_down = door_down, door_in = door_in, door_out = door_out, special = special, portals = portals}
        tmp = {}
        for k1,v1 in pairs(exits) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.exits[v] = tmp
        end
        tmp = {}
        for k1,v1 in pairs(special) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.special[v] = tmp
        end
    end
    local path = profilePath.."/"..string.gsub(string.lower(name),"%s","_")..".dat"
    table.save(path,tbl)
    map.echo("Area " .. name .. " exported to " .. path)
end

function map.import_area(name)
    name = profilePath .. "/" .. string.gsub(string.lower(name),"%s","_") .. ".dat"
    local tbl = {}
    table.load(name,tbl)
    if table.is_empty(tbl) then
        show_err("No file found")
    end
    local areas = getAreaTable()
    local areaID = areas[tbl.name] or addAreaName(tbl.name)
    local rooms = {}
    local ID
    for k,v in pairs(tbl.rooms) do
        ID = createRoomID()
        rooms[k] = ID
        addRoom(ID)
        setRoomName(ID,v.name)
        setRoomArea(ID,areaID)
        setRoomCoordinates(ID,unpack(v.coords))
        if type(v.stubs) == "table" then
            for i,j in pairs(v.stubs) do
                setExitStub(ID,j,true)
            end
        end
        for i,j in pairs(v.doors) do
            setDoor(ID,i,j)
        end
        setRoomUserData(ID,"portals",v.portals)
    end
    for k,v in pairs(tbl.rooms) do
        for i,j in pairs(v.exits) do
            if rooms[j] then
                connect_rooms(rooms[k],rooms[j],i)
            end
        end
        for i,j in pairs(v.special) do
            if rooms[j] then
                addSpecialExit(rooms[k],rooms[j],i)
            end
        end
    end
    for k,v in pairs(tbl.exits) do
        for i,j in pairs(v) do
            if getRoomName(j[1]) == j[2] then
                connect_rooms(rooms[k],j[1],i)
            end
        end
    end
    for k,v in pairs(tbl.special) do
        for i,j in pairs(v) do
            addSpecialExit(k,j[1],i)
        end
    end
    map.fix_portals()
    map.echo("Area " .. tbl.name .. " imported from " .. name)
end

function map.set_recall()
    -- assigned the current room to be recall for the current character
    map.save.recall[map.character] = map.currentRoom
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Recall room set to: " .. getRoomName(map.currentRoom) .. ".")
end

function map.set_portal(name, is_auto)
    -- creates a new portal in the room
    if map.mapping then
        if not string.starts(name,"-f ") then
            find_portal = name
        else
            name = string.gsub(name,"^-f ","")
            force_portal = name
        end
        move_queue = {name}
        if not is_auto then
            send(name)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_mode(mode)
    -- switches mapping modes
    if not table.contains({"lazy","simple","normal","complex"},mode) then
        show_err("Invalid Map Mode, must be 'lazy', 'simple', 'normal' or 'complex'.")
    end
    map.set("mode", mode)
    map.echo("Current mode set to: " .. mode)
end

function map.start_mapping(area_name)
    -- starts mapping, and sets the current area to the given one, or uses the current one
    if not map.currentName then
        show_err("Room detection not yet working, see &lt;yellow&gt;map basics&lt;reset&gt; for guidance.")
    end
    local rooms
    move_queue = {}
    area_name = area_name ~= "" and area_name or nil
    if map.currentArea and not area_name then
        local areas = getAreaTableSwap()
        area_name = areas[map.currentArea]
    end
    if not area_name then
        show_err("You haven't started mapping yet, how should the first area be called? Set it with: &lt;yellow&gt;start mapping &lt;area name&gt;&lt;reset&gt;")
    end
    map.echo("Now mapping in area: " .. area_name)
    map.set("mapping", true)
    find_area(area_name)
    rooms = find_room(map.currentName, map.currentArea)
    if table.is_empty(rooms) then
        if map.currentRoom and getRoomName(map.currentRoom) == map.currentName then
            map.set_area(area_name)
        else
            create_room(map.currentName, map.currentExits, nil, {0,0,0})
        end
    elseif map.currentRoom and map.currentArea ~= getRoomArea(map.currentRoom) then
        map.set_area(area_name)
    end
end

function map.stop_mapping()
    map.set("mapping", false)
    map.echo("Mapping off.")
end

function map.clear_moves()
    local commands_in_queue = #move_queue
    move_queue = {}
    map.echo("Move queue cleared, "..commands_in_queue.." commands removed.")
end

function map.show_moves()
    map.echo("Moves: "..(move_queue and table.concat(move_queue, ', ') or '(queue empty)'))
end

function map.set_area(name)
    -- assigns the current room to the area given, creates the area if necessary
    if map.mapping then
        find_area(name)
        if map.currentRoom and getRoomArea(map.currentRoom) ~= map.currentArea then
            setRoomArea(map.currentRoom,map.currentArea)
            set_room(map.currentRoom)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_door(dir,status,one_way)
    -- adds a door on a given exit
    if map.mapping then
        if not map.currentRoom then
            show_err("Make Door: No room found.")
        end
        dir = exitmap[dir] or dir
        if not stubmap[dir] then
            show_err("Make Door: Invalid direction.")
        end
        status = (status ~= "" and status) or "closed"
        one_way = (one_way ~= "" and one_way) or "no"
        if not table.contains({"yes","no"},one_way) then
            show_err("Make Door: Invalid one-way status, must be yes or no.")
        end

        local exits = getRoomExits(map.currentRoom)
        local exit
        -- check handling of custom exits here
        for i = 13,#stubmap do
            exit = "exit " .. stubmap[i]
            exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,exit))
        end
        local target_room = exits[dir]
        if target_room then
            exits = getRoomExits(target_room)
            -- check handling of custom exits here
            for i = 13,#stubmap do
                exit = "exit " .. stubmap[i]
                exits[stubmap[i]] = tonumber(getRoomUserData(target_room,exit))
            end
        end
        if one_way == "no" and (target_room and exits[reverse_dirs[dir]] == map.currentRoom) then
            add_door(target_room,reverse_dirs[dir],status)
        end
        add_door(map.currentRoom,dir,status)
        map.echo(string.format("Adding %s door to the %s", status, dir))
    else
        map.echo("Not mapping",false,true)
    end
end

function map.shift_room(dir)
    -- shifts a room around on the map
    if map.mapping then
        dir = exitmap[dir] or (table.contains(exitmap,dir) and dir)
        if not dir then
            show_err("Shift Room: Exit not found")
        end
        local x,y,z = getRoomCoordinates(map.currentRoom)
        dir = stubmap[dir]
        local coords = coordmap[dir]
        x = x + coords[1]
        y = y + coords[2]
        z = z + coords[3]
        setRoomCoordinates(map.currentRoom,x,y,z)
        centerview(map.currentRoom)
        map.echo("Shifting room",true)
    else
        map.echo("Not mapping",false,true)
    end
end

local function check_link(firstID, secondID, dir)
    -- check to see if two rooms are connected in a given direction
    if not firstID then error("Check Link Error: No first ID",2) end
    if not secondID then error("Check Link Error: No second ID",2) end
    local name = getRoomName(firstID)
    local exits1 = table.union(getRoomExits(firstID),getRoomStubs(firstID))
    local exits2 = table.union(getRoomExits(secondID),getRoomStubs(secondID))
    local exit
    -- check handling of custom exits here
    for i = 13,#stubmap do
        exit = "exit " .. stubmap[i]
        exits1[stubmap[i]] = tonumber(getRoomUserData(firstID,exit))
        exits2[stubmap[i]] = tonumber(getRoomUserData(secondID,exit))
    end
    local checkID = exits2[reverse_dirs[dir]]
    local exits = {}
    for k,v in pairs(exits1) do
        table.insert(exits,k)
    end
    return checkID and check_room(checkID,name,exits)
end

function map.find_me(name, exits, dir, manual)
    -- tries to locate the player using the current room name and exits, and if provided, direction of movement
    -- if direction of movement is given, narrows down possibilities using previous room info
    if move ~= "recall" then move_queue = {} end
    local check = dir and map.currentRoom and table.contains(exitmap,dir)
    name = name or map.currentName
    exits = exits or map.currentExits
    if not name and not exits then
        show_err("Room not found, complete room name and exit data not available.")
    end
    local rooms = find_room(name)
    local match_IDs = {}
    for k,v in pairs(rooms) do
        if check_room(k, name, exits) then
            table.insert(match_IDs,k)
        end
    end
    rooms = match_IDs
    match_IDs = {}
    if table.size(rooms) &gt; 1 and check then
        for k,v in pairs(rooms) do
            if check_link(map.currentRoom,v,dir) then
                table.insert(match_IDs,v)
            end
        end
    elseif random_move then
        for k,v in pairs(getRoomExits(map.currentRoom)) do
            if check_room(v,map.currentName,map.currentExits) then
                table.insert(match_IDs,v)
            end
        end
    end
    if table.size(match_IDs) == 0 then
        match_IDs = rooms
    end
    if table.contains(match_IDs,map.currentRoom) then
        match_IDs = {map.currentRoom}
    end
    if not table.is_empty(match_IDs) and not find_portal then
        set_room(match_IDs[1])
        map.echo("Room found, ID: " .. match_IDs[1],true)
    elseif find_portal then
        if not table.is_empty(match_IDs) then
            map.echo("Found portal destination, linking rooms",false,false,true)
            addSpecialExit(map.currentRoom,match_IDs[1],find_portal)
            local portals = getRoomUserData(match_IDs[1],"portals") or ""
            portals = portals .. "," .. tostring(map.currentRoom)..":"..find_portal
            setRoomUserData(match_IDs[1],"portals",portals)
            set_room(match_IDs[1])
            map.echo("Room found, ID: " .. match_IDs[1],true)
        else
            map.echo("Creating portal destination",false,false,true)
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
        end
        find_portal = false
    elseif table.is_empty(match_IDs) then
        if not manual then
            map.echo("Room not found in map database", true, true)
        else
            map.echo("Room not found in map database", false, true)
        end
    end
end

function map.fix_portals()
    if map.mapping then
        -- used to clear and update data for portal back-referencing
        local rooms = getRooms()
        local portals
        for k,v in pairs(rooms) do
            setRoomUserData(k,"portals","")
        end
        for k,v in pairs(rooms) do
            for cmd,room in pairs(getSpecialExitsSwap(k)) do
                portals = getRoomUserData(room,"portals") or ""
                if portals ~= "" then portals = portals .. "," end
                portals = portals .. tostring(k) .. ":" .. cmd
                setRoomUserData(room,"portals",portals)
            end
        end
        map.echo("Portals Fixed")
    else
        map.echo("Not mapping",false,true)
    end
end

function map.merge_rooms()
    -- used to combine essentially identical rooms with the same coordinates
    -- typically, these are generated due to mapping errors
    if map.mapping then
        map.echo("Merging rooms")
        local x,y,z = getRoomCoordinates(map.currentRoom)
        local rooms = getRoomsByPosition(map.currentArea,x,y,z)
        local exits, portals, room, cmd, curportals
        local room_count = 1
        for k,v in pairs(rooms) do
            if v ~= map.currentRoom then
                if getRoomName(v) == getRoomName(map.currentRoom) then
                    room_count = room_count + 1
                    for k1,v1 in pairs(getRoomExits(v)) do
                        setExit(map.currentRoom,v1,stubmap[k1])
                        exits = getRoomExits(v1)
                        if exits[reverse_dirs[k1]] == v then
                            setExit(v1,map.currentRoom,stubmap[reverse_dirs[k1]])
                        end
                    end
                    for k1,v1 in pairs(getDoors(v)) do
                        setDoor(map.currentRoom,k1,v1)
                    end
                    for k1,v1 in pairs(getSpecialExitsSwap(v)) do
                        addSpecialExit(map.currentRoom,v1,k1)
                    end
                    portals = getRoomUserData(v,"portals") or ""
                    if portals ~= "" then
                        portals = string.split(portals,",")
                        for k1,v1 in ipairs(portals) do
                            room,cmd = unpack(string.split(v1,":"))
                            addSpecialExit(tonumber(room),map.currentRoom,cmd)
                            curportals = getRoomUserData(map.currentRoom,"portals") or ""
                            if not string.find(curportals,room) then
                                curportals = curportals .. "," .. room .. ":" .. cmd
                                setRoomUserData(map.currentRoom,"portals",curportals)
                            end
                        end
                    end
                    -- check handling of custom exits here for doors and exits, and reverse exits
                    for i = 13,#stubmap do
                        local door = "door " .. stubmap[i]
                        local tmp = tonumber(getRoomUserData(v,door))
                        if tmp then
                            setRoomUserData(map.currentRoom,door,tmp)
                        end
                        local exit = "exit " .. stubmap[i]
                        tmp = tonumber(getRoomUserData(v,exit))
                        if tmp then
                            setRoomUserData(map.currentRoom,exit,tmp)
                            if tonumber(getRoomUserData(tmp, "exit " .. reverse_dirs[stubmap[i]])) == v then
                                setRoomUserData(tmp, exit, map.currentRoom)
                            end
                        end
                    end
                    deleteRoom(v)
                end
            end
        end
        if room_count &gt; 1 then
            map.echo(room_count .. " rooms merged", true)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.findAreaID(areaname, exact)
    local areaname = areaname:lower()
    local list = getAreaTable()

    -- iterate over the list of areas, matching them with substring match.
    -- if we get match a single area, then return its ID, otherwise return
    -- 'false' and a message that there are than one are matches
    local returnid, fullareaname, multipleareas = nil, nil, {}
    for area, id in pairs(list) do
        if (not exact and area:lower():find(areaname, 1, true)) or (exact and areaname == area:lower()) then
            returnid = id
            fullareaname = area
            multipleareas[#multipleareas+1] = area
        end
    end

    if #multipleareas == 1 then
        return returnid, fullareaname
    else
        return nil, nil, multipleareas
    end
end

function map.echoRoomList(areaname, exact)
    local areaid, msg, multiples
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"
    if tonumber(areaname) then
        areaid = tonumber(areaname)
        msg = getAreaTableSwap()[areaid]
    else
        areaid, msg, multiples = map.findAreaID(areaname, exact)
    end
    if areaid then
        local roomlist, endresult = getAreaRooms(areaid) or {}, {}

        -- obtain a room list for each of the room IDs we got
        local getRoomName = getRoomName
        for _, id in pairs(roomlist) do
            endresult[id] = getRoomName(id)
        end
        roomlist[#roomlist+1], roomlist[0] = roomlist[0], nil
        -- sort room IDs so we can display them in order
        table.sort(roomlist)

        local echoLink, format, fg, echo = echoLink, string.format, fg, cecho
        -- now display something half-decent looking
        cecho(format("&lt;%s&gt;List of all rooms in &lt;%s&gt;%s&lt;%s&gt; (areaID &lt;%s&gt;%s&lt;%s&gt; - &lt;%s&gt;%d&lt;%s&gt; rooms):\n",
            listcolor, othercolor, msg, listcolor, othercolor, areaid, listcolor, othercolor, #roomlist, listcolor))
        -- use pairs, as we can have gaps between room IDs
        for _, roomid in pairs(roomlist) do
            local roomname = endresult[roomid]
            cechoLink(format("&lt;%s&gt;%7s",othercolor,roomid), 'map.speedwalk('..roomid..')',
                format("Go to %s (%s)", roomid, tostring(roomname)), true)
            cecho(format("&lt;%s&gt;: &lt;%s&gt;%s&lt;%s&gt;.\n", listcolor, othercolor, roomname, listcolor))
        end
    elseif not areaid and #multiples &gt; 0 then
        local allareas, format = getAreaTable(), string.format
        local function countrooms(areaname)
            local areaid = allareas[areaname]
            local allrooms = getAreaRooms(areaid) or {}
            local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
            return areac
        end
        map.echo("For which area would you want to list rooms for?")
        for _, areaname in ipairs(multiples) do
            echo("  ")
            setUnderline(true)
            cechoLink(format("&lt;%s&gt;%-40s (%d rooms)", othercolor, areaname, countrooms(areaname)),
                'map.echoRoomList("'..areaname..'", true)', "Click to view the room list for "..areaname, true)
            setUnderline(false)
            echo("\n")
        end
    else
        map.echo(string.format("Don't know of any area named '%s'.", areaname),false,true)
    end
    resetFormat()
end

function map.echoAreaList()
    local totalroomcount = 0
    local rlist = getAreaTableSwap()
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"

    -- count the amount of rooms in an area, taking care to count the room in the 0th
    -- index as well if there is one
    -- saves the total room count on the side as well
    local function countrooms(areaid)
        local allrooms = getAreaRooms(areaid) or {}
        local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
        totalroomcount = totalroomcount + areac
        return areac
    end

    local getAreaRooms, cecho, fg, echoLink, format = getAreaRooms, cecho, fg, echoLink, string.format
    cecho(format("&lt;%s&gt;List of all areas we know of (click to view room list):\n",listcolor))
    for id = 1,table.maxn(rlist) do
        if rlist[id] then
            cecho(format("&lt;%s&gt;%7d ", othercolor, id))
            fg(listcolor)
            echoLink(format("%-40s (%d rooms)",rlist[id],countrooms(id)), 'map.echoRoomList("'..id..'", true)',
                "View the room list for "..rlist[id], true)
            echo("\n")
        end
    end
    cecho(string.format("&lt;%s&gt;Total amount of rooms in this map: %s\n", listcolor, totalroomcount))
end

function map.search_timer_check()
    if find_prompt then
        map.echo("Prompt not auto-detected, use 'map prompt' to set a prompt pattern.",false,true)
        find_prompt = false
    end
end

function map.find_prompt()
    find_prompt = true
    map.echo("Searching for prompt.")
    send("\n", false)
    tempTimer(5, "map.search_timer_check()")
end

function map.make_prompt_pattern(str)
    if not str:starts("^") then str = "^"..str end
    map.save.prompt_pattern[map.character] = str
    find_prompt = false
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Prompt pattern set: " .. str)
end

function map.make_ignore_pattern(str)
    map.save.ignore_patterns = map.save.ignore_patterns or {}
    if not table.contains(map.save.ignore_patterns,str) then
        table.insert(map.save.ignore_patterns,str)
        map.echo("Ignore pattern added: " .. str)
    else
        table.remove(map.save.ignore_patterns, table.index_of(map.save.ignore_patterns, str))
        map.echo("Ignore pattern removed: " .. str)
    end
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
end

local function grab_line()
    table.insert(lines,line)
    if map.save.prompt_pattern[map.character] and string.match(line, map.save.prompt_pattern[map.character]) then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt captured",true)
    end
    if find_prompt then
        for k,v in ipairs(map.configs.prompt_test_patterns) do
            if string.match(line,v) then
                map.save.prompt_pattern[map.character] = v
                table.save(profilePath .. "/map downloads/map_save.dat",map.save)
                find_prompt = false
                map.echo("Prompt found")
                break
            end
        end
    end
end

local function name_search()
    local room_name
    if map.configs.custom_name_search then
        room_name = mudlet.custom_name_search(lines)
    else
        local line_count = #lines + 1
        local cur_line, last_line
        local prompt_pattern = map.save.prompt_pattern[map.character]
        if not prompt_pattern then return end
        while not room_name do
            line_count = line_count - 1
            if not lines[line_count] then break end
            cur_line = lines[line_count]
            for k,v in ipairs(map.save.ignore_patterns) do
                cur_line = string.trim(string.gsub(cur_line,v,""))
            end
            if string.find(cur_line,prompt_pattern) then
                cur_line = string.trim(string.gsub(cur_line,prompt_pattern,""))
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif line_count == 1 then
                cur_line = string.trim(cur_line)
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif not string.match(cur_line,"^%s*$") then
                last_line = cur_line
            end
        end
        lines = {}
        room_name = room_name:sub(1,100)
    end
    return room_name
end

local function handle_exits(exits)
    local room = map.prompt.room or name_search()
    room = map.sanitizeRoomName(room)
    exits = map.prompt.exits or exits
    exits = string.lower(exits)
    exits = string.gsub(exits,"%a+", exitmap)
    if room then
        map.echo("Room Name Captured: " .. room, true)
        room = string.trim(room)
        capture_room_info(room, exits)
        map.prompt.room = nil
        map.prompt.exits = nil
    end
end

local continue_walk, timerID
continue_walk = function(new_room)
    if not walking then return end
    -- calculate wait time until next command, with randomness
    local wait = map.configs.speedwalk_delay or 0
    if wait &gt; 0 and map.configs.speedwalk_random then
        wait = wait * (1 + math.random(0,100)/100)
    end
    -- if no wait after new room, move immediately
    if new_room and map.configs.speedwalk_wait and wait == 0 then
        new_room = false
    end
    -- send command if we don't need to wait
    if not new_room then
        send(table.remove(map.walkDirs,1))
        -- check to see if we are done
        if #map.walkDirs == 0 then
            walking = false
        end
    end
    -- make tempTimer to send next command if necessary
    if walking and (not map.configs.speedwalk_wait or (map.configs.speedwalk_wait and wait &gt; 0)) then
        if timerID then killTimer(timerID) end
        timerID = tempTimer(wait, function() continue_walk() end)
    end
end

function map.speedwalk(roomID, walkPath, walkDirs)
    roomID = roomID or speedWalkPath[#speedWalkPath]
    getPath(map.currentRoom, roomID)
    walkPath = speedWalkPath
    walkDirs = speedWalkDir
    if #speedWalkPath == 0 then
        map.echo("No path to chosen room found.",false,true)
        return
    end
    table.insert(walkPath, 1, map.currentRoom)
    -- go through dirs to find doors that need opened, etc
    -- add in necessary extra commands to walkDirs table
    local k = 1
    repeat
        local id, dir = walkPath[k], walkDirs[k]
        if exitmap[dir] or short[dir] then
            local door = check_doors(id, exitmap[dir] or dir)
            local status = door and door[dir]
            if status and status &gt; 1 then
                -- if locked, unlock door
                if status == 3 then
                    table.insert(walkPath,k,id)
                    table.insert(walkDirs,k,"unlock " .. (exitmap[dir] or dir))
                    k = k + 1
                end
                -- if closed, open door
                table.insert(walkPath,k,id)
                table.insert(walkDirs,k,"open " .. (exitmap[dir] or dir))
                k = k + 1
            end
        end
        k = k + 1
    until k &gt; #walkDirs
    if map.configs.use_translation then
        for k, v in ipairs(walkDirs) do
            walkDirs[k] = map.configs.lang_dirs[v] or v
        end
    end
    -- perform walk
    walking = true
    if map.configs.speedwalk_wait or map.configs.speedwalk_delay &gt; 0 then
        map.walkDirs = walkDirs
        continue_walk()
    else
        for _,dir in ipairs(walkDirs) do
            send(dir)
        end
        walking = false
    end
end

function doSpeedWalk()
    if #speedWalkPath ~= 0 then
        map.speedwalk(nil, speedWalkPath, speedWalkDir)
    else
        map.echo("No path to chosen room found.",false,true)
    end
end

local function check_version()
    downloading = false
    local path = profilePath .. "/map downloads/versions.lua"
    local versions = {}
    table.load(path, versions)
    local pos = table.index_of(versions, map.version) or 0
    if pos ~= #versions then
        enableAlias("Map Update Alias")
        map.echo(string.format("The Generic Mapping Script is currently &lt;red&gt;%d&lt;reset&gt; versions behind.",#versions - pos))
        map.echo("To update now, please type: &lt;yellow&gt;map update&lt;reset&gt;")
    end
    map.update_timer = tempTimer(3600, [[map.checkVersion()]])
end

function map.checkVersion()
    if map.update_timer then
        killTimer(map.update_timer)
        map.update_timer = nil
    end
    if not map.update_waiting and map.configs.download_path ~= "" then
        local path, file = profilePath .. "/map downloads", "/versions.lua"
        downloading = true
        downloadFile(path .. file, map.configs.download_path .. file)
        map.update_waiting = true
    end
end

local function update_version()
    downloading = false
    local path = profilePath .. "/map downloads/generic_mapper.xml"
    disableAlias("Map Update Alias")
    map.updatingMapper = true
    uninstallPackage("generic_mapper")
    installPackage(path)
    map.updatingMapper = nil
    map.echo("Generic Mapping Script updated successfully.")
end

function map.updateVersion()
    local path, file = profilePath .. "/map downloads", "/generic_mapper.xml"
    downloading = true
    downloadFile(path .. file, map.configs.download_path .. file)
end

function map.showMap(shown)
    local configs = map.configs.map_window
    shown = shown or not configs.shown
    map.configs.map_window.shown = shown
    local x, y, w, h, origin = configs.x, configs.y, configs.w, configs.h, configs.origin
    if string.find(origin,"bottom") then
        if y == 0 or y == "0%" then
            y = h
        end
        if type(y) == "number" then
            y = -y
        else
            y = "-"..y
        end
    end
    if string.find(origin,"right") then
        if x == 0 or x == "0%" then
            x = w
        end
        if type(x) == "number" then
            x = -x
        else
            x = "-"..x
        end
    end
    local mapper = Geyser.Mapper:new({name = "my_mapper", x = x, y = y, w = w, h = h})
    mapper:resize(w,h)
    mapper:move(x,y)
    if shown then
        mapper:show()
    else
        mapper:hide()
    end
end

-- some games embed an ASCII map on the same line, which messes up the room room name
-- extract the longest continuous piece of text from the line to be the room name
function map.sanitizeRoomName(roomtitle)
  assert(type(roomtitle) == "string", "map.sanitizeRoomName: bad argument #1 expected room title, got "..type(roomtitle).."!")
  if not roomtitle:match("  ") then return roomtitle end
  
  local parts = roomtitle:split("  ")
  table.sort(parts, function(a,b) return #a &lt; #b end)
  local longestpart = parts[#parts]
  
  local trimmed = utf8.match(longestpart, "[%w ]+"):trim()
  return trimmed
end

function map.eventHandler(event, ...)
    if event == "onNewRoom" then
        handle_exits(arg[1])
        if walking and map.configs.speedwalk_wait then
            continue_walk(true)
        end
    elseif event == "onPrompt" then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt Captured",true)
    elseif event == "onMoveFail" then
        map.echo("onMoveFail",true)
        table.remove(move_queue,1)
    elseif event == "onVisionFail" then
        map.echo("onVisionFail",true)
        vision_fail = true
        capture_room_info()
    elseif event == "onRandomMove" then
        map.echo("onRandomMove",true)
        random_move = true
        move_queue = {}
    elseif event == "onForcedMove" then
        map.echo("onForcedMove",true)
        capture_move_cmd(arg[1],arg[2]=="true")
    elseif event == "onNewLine" then
        grab_line()
    elseif event == "sysDataSendRequest" then
        capture_move_cmd(arg[1])
        -- check to prevent multiple version checks in a row without user intervention
        if map.update_waiting and map.update_timer then
            map.update_waiting = nil
        -- check to ensure version check cycle is started
        elseif not map.update_waiting and not map.update_timer then
            map.checkVersion()
        end
    elseif event == "sysDownloadDone" and downloading then
        local file = arg[1]
        if string.ends(file,"/map.dat") then
            loadMap(file)
            downloading = false
            map.echo("Map File Loaded.")
        elseif string.ends(file,"/versions.lua") then
            check_version()
        elseif string.ends(file,"/generic_mapper.xml") then
            update_version()
        end
    elseif event == "sysLoadEvent" or event == "sysInstall" then
        config()
    elseif event == "mapOpenEvent" then
        if not help_shown and not map.save.prompt_pattern[map.character or ""] then
            map.find_prompt()
            send(map.configs.lang_dirs['look'], true)
            tempTimer(3, function() map.show_help("quick_start"); help_shown = true end)
        end
    elseif event == "mapStop" then
        map.set("mapping", false)
        walking = false
        map.echo("Mapping and speedwalking stopped.")
    elseif event == "sysManualLocationSetEvent" then
      set_room(arg[1])
    elseif event == "sysUninstallPackage" and not map.updatingMapper and arg[1] == "generic_mapper" then
        for _,id in ipairs(map.registeredEvents) do
            killAnonymousEventHandler(id)
        end
    end
end
				
map.registeredEvents = {
registerAnonymousEventHandler("sysDownloadDone", "map.eventHandler"),
registerAnonymousEventHandler("sysLoadEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysConnectionEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysInstall", "map.eventHandler"),
registerAnonymousEventHandler("sysDataSendRequest", "map.eventHandler"),
registerAnonymousEventHandler("onMoveFail", "map.eventHandler"),
registerAnonymousEventHandler("onVisionFail", "map.eventHandler"),
registerAnonymousEventHandler("onRandomMove", "map.eventHandler"),
registerAnonymousEventHandler("onForcedMove", "map.eventHandler"),
registerAnonymousEventHandler("onNewRoom", "map.eventHandler"),
registerAnonymousEventHandler("onNewLine", "map.eventHandler"),
registerAnonymousEventHandler("mapOpenEvent", "map.eventHandler"),
registerAnonymousEventHandler("mapStop", "map.eventHandler"),
registerAnonymousEventHandler("onPrompt", "map.eventHandler"),
registerAnonymousEventHandler("sysManualLocationSetEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysUninstallPackage", "map.eventHandler")
}
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>MAG_110</name>
			<packageName>MAG_110</packageName>
			<script></script>
			<command></command>
			<keyCode>0</keyCode>
			<keyModifier>0</keyModifier>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>MAG</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>4294967295</keyModifier>
				<KeyGroup isActive="yes" isFolder="yes">
					<name>Navigation</name>
					<packageName></packageName>
					<script></script>
					<command></command>
					<keyCode>-1</keyCode>
					<keyModifier>4294967295</keyModifier>
					<KeyGroup isActive="no" isFolder="yes">
						<name>NumPad movement</name>
						<packageName></packageName>
						<script>-- TODO I don't have full keyboard, so I wasn't able to set that up</script>
						<command></command>
						<keyCode>16777268</keyCode>
						<keyModifier>0</keyModifier>
						<Key isActive="no" isFolder="no">
							<name>N</name>
							<packageName></packageName>
							<script></script>
							<command>n</command>
							<keyCode>-1</keyCode>
							<keyModifier>4294967295</keyModifier>
						</Key>
						<Key isActive="no" isFolder="no">
							<name>S</name>
							<packageName></packageName>
							<script></script>
							<command>s</command>
							<keyCode>-1</keyCode>
							<keyModifier>4294967295</keyModifier>
						</Key>
						<Key isActive="no" isFolder="no">
							<name>E</name>
							<packageName></packageName>
							<script></script>
							<command>e</command>
							<keyCode>-1</keyCode>
							<keyModifier>4294967295</keyModifier>
						</Key>
						<Key isActive="no" isFolder="no">
							<name>W</name>
							<packageName></packageName>
							<script></script>
							<command>w</command>
							<keyCode>-1</keyCode>
							<keyModifier>4294967295</keyModifier>
						</Key>
						<Key isActive="no" isFolder="no">
							<name>U</name>
							<packageName></packageName>
							<script></script>
							<command>u</command>
							<keyCode>-1</keyCode>
							<keyModifier>4294967295</keyModifier>
						</Key>
						<Key isActive="no" isFolder="no">
							<name>D</name>
							<packageName></packageName>
							<script></script>
							<command>d</command>
							<keyCode>-1</keyCode>
							<keyModifier>4294967295</keyModifier>
						</Key>
					</KeyGroup>
					<KeyGroup isActive="yes" isFolder="yes">
						<name>WSAD movement</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>-1</keyCode>
						<keyModifier>4294967295</keyModifier>
						<Key isActive="yes" isFolder="no">
							<name>N</name>
							<packageName></packageName>
							<script></script>
							<command>n</command>
							<keyCode>87</keyCode>
							<keyModifier>33554432</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>S</name>
							<packageName></packageName>
							<script></script>
							<command>s</command>
							<keyCode>83</keyCode>
							<keyModifier>33554432</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>E</name>
							<packageName></packageName>
							<script></script>
							<command>e</command>
							<keyCode>68</keyCode>
							<keyModifier>33554432</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>W</name>
							<packageName></packageName>
							<script></script>
							<command>w</command>
							<keyCode>65</keyCode>
							<keyModifier>33554432</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>U</name>
							<packageName></packageName>
							<script></script>
							<command>u</command>
							<keyCode>69</keyCode>
							<keyModifier>33554432</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>D</name>
							<packageName></packageName>
							<script></script>
							<command>d</command>
							<keyCode>81</keyCode>
							<keyModifier>33554432</keyModifier>
						</Key>
					</KeyGroup>
					<Key isActive="yes" isFolder="no">
						<name>glance, map and exits</name>
						<packageName></packageName>
						<script></script>
						<command>gla;; m;; exits</command>
						<keyCode>35</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>open all directions</name>
						<packageName></packageName>
						<script>
utils.startGagEmptyLines()
utils.hidePrompt()
send("o n;;o s;;o w;;o e;;o u;;o d")
send("m", false)
utils.stopGagEmptyLinesOn("{open-all-end}")
send("echo {open-all-end}", false)
utils.showPrompt()
</script>
						<command></command>
						<keyCode>126</keyCode>
						<keyModifier>33554432</keyModifier>
					</Key>
				</KeyGroup>
				<KeyGroup isActive="yes" isFolder="yes">
					<name>Function Keys</name>
					<packageName></packageName>
					<script></script>
					<command></command>
					<keyCode>-1</keyCode>
					<keyModifier>4294967295</keyModifier>
					<Key isActive="yes" isFolder="no">
						<name>F1 heal</name>
						<packageName></packageName>
						<script></script>
						<command>c 26</command>
						<keyCode>16777264</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F2 spellup</name>
						<packageName></packageName>
						<script>su.forceSpellUpMe()</script>
						<command></command>
						<keyCode>16777265</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F3 old attack spell</name>
						<packageName></packageName>
						<script></script>
						<command>cast 12</command>
						<keyCode>16777266</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F4 attack spell</name>
						<packageName></packageName>
						<script></script>
						<command>cast 363</command>
						<keyCode>16777267</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F5</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777268</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F6</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777269</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F7</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777270</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F8</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777271</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F9</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777272</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F10</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777273</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F11</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777274</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F12</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777275</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
				</KeyGroup>
			</KeyGroup>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
